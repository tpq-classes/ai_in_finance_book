diff --git a/01_artificial_intelligence.ipynb b/01_artificial_intelligence.ipynb
index ae73912..83cb599 100755
--- a/01_artificial_intelligence.ipynb
+++ b/01_artificial_intelligence.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -92,22 +92,51 @@
     "model = KMeans(n_clusters=4, random_state=0)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "364c9d0c",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "model.fit(x)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "03926041",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "model.fit(x)"
+    "model.fit(x, verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "f5ca73b6",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y_ = model.predict(x)"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "25e8bb8c",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y_ = model.predict(x)"
+    "import tensorflow as tf\n",
+    "y_ = model(tf.convert_to_tensor(x, dtype=tf.float32), training=False).numpy()"
    ]
   },
   {
@@ -393,22 +422,51 @@
     "                     max_iter=5000, random_state=1000)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "ec344db6",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%time model.fit(x.reshape(-1, 1), y)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "4dee748e",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "%time model.fit(x.reshape(-1, 1), y)"
+    "%time model.fit(x.reshape(-1, 1, verbose=0), y)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "318b68dc",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y_ = model.predict(x.reshape(-1, 1))"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "8a174575",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y_ = model.predict(x.reshape(-1, 1))"
+    "import tensorflow as tf\n",
+    "y_ = model(tf.convert_to_tensor(x.reshape(-1, 1, dtype=tf.float32), training=False).numpy())"
    ]
   },
   {
@@ -510,17 +568,40 @@
     "((y - y_) ** 2).mean()"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "12c3a80a",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(x, y, 'ro', label='sample data')\n",
+    "for _ in range(1, 6):\n",
+    "    model.fit(x, y, epochs=100, verbose=False)\n",
+    "    y_ =  model.predict(x)\n",
+    "    MSE = ((y - y_.flatten()) ** 2).mean()\n",
+    "    print(f'round={_} | MSE={MSE:.5f}')\n",
+    "    plt.plot(x, y_, '--', label=f'round={_}')\n",
+    "plt.legend();"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "2cfb61e3",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "plt.figure(figsize=(10, 6))\n",
     "plt.plot(x, y, 'ro', label='sample data')\n",
     "for _ in range(1, 6):\n",
     "    model.fit(x, y, epochs=100, verbose=False)\n",
-    "    y_ =  model.predict(x)\n",
+    "    y_ =  model(tf.convert_to_tensor(x, dtype=tf.float32), training=False).numpy()\n",
     "    MSE = ((y - y_.flatten()) ** 2).mean()\n",
     "    print(f'round={_} | MSE={MSE:.5f}')\n",
     "    plt.plot(x, y_, '--', label=f'round={_}')\n",
@@ -594,18 +675,42 @@
     "model.summary()"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "ec0e94ab",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%%time\n",
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(x, y, 'ro', label='sample data')\n",
+    "for _ in range(1, 8):\n",
+    "    model.fit(x, y, epochs=500, verbose=False)\n",
+    "    y_ =  model.predict(x)\n",
+    "    MSE = ((y - y_.flatten()) ** 2).mean()\n",
+    "    print(f'round={_} | MSE={MSE:.5f}')\n",
+    "    plt.plot(x, y_, '--', label=f'round={_}')\n",
+    "plt.legend();"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "9dfc89c3",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "%%time\n",
     "plt.figure(figsize=(10, 6))\n",
     "plt.plot(x, y, 'ro', label='sample data')\n",
     "for _ in range(1, 8):\n",
     "    model.fit(x, y, epochs=500, verbose=False)\n",
-    "    y_ =  model.predict(x)\n",
+    "    y_ =  model(tf.convert_to_tensor(x, dtype=tf.float32), training=False).numpy()\n",
     "    MSE = ((y - y_.flatten()) ** 2).mean()\n",
     "    print(f'round={_} | MSE={MSE:.5f}')\n",
     "    plt.plot(x, y_, '--', label=f'round={_}')\n",
@@ -680,13 +785,29 @@
     "hist = model.fit(x, y, epochs=50, verbose=False)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "ffc5810d",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y_ = np.where(model.predict(x).flatten() > 0.5, 1, 0)\n",
+    "y_"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "30a168ff",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y_ = np.where(model.predict(x).flatten() > 0.5, 1, 0)\n",
+    "import tensorflow as tf\n",
+    "y_ = np.where(model(tf.convert_to_tensor(x, dtype=tf.float32), training=False).numpy().flatten() > 0.5, 1, 0)\n",
     "y_"
    ]
   },
@@ -859,22 +980,51 @@
     "                      max_iter=1000, random_state=100)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "a0b85faa",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "model.fit(data[fcols], data['l'])"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "d5be7b3e",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "model.fit(data[fcols], data['l'])"
+    "model.fit(data[fcols], data['l'], verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "6c19c995",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "accuracy_score(data['l'], model.predict(data[fcols]))"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "1eed5ea6",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "accuracy_score(data['l'], model.predict(data[fcols]))"
+    "import tensorflow as tf\n",
+    "accuracy_score(data['l'], model(tf.convert_to_tensor(data[fcols], dtype=tf.float32), training=False).numpy())"
    ]
   },
   {
@@ -897,10 +1047,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "3c173a12",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "model.fit(train[fcols], train['l'])"
    ]
@@ -908,8 +1060,22 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "52f5e898",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "model.fit(train[fcols], train['l'], verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "5af2450e",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "accuracy_score(train['l'], model.predict(train[fcols]))"
    ]
@@ -917,12 +1083,40 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "481e3791",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "accuracy_score(train['l'], model(tf.convert_to_tensor(train[fcols], dtype=tf.float32), training=False).numpy())"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "d15c7533",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "accuracy_score(test['l'], model.predict(test[fcols]))"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "a9d280d1",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "accuracy_score(test['l'], model(tf.convert_to_tensor(test[fcols], dtype=tf.float32), training=False).numpy())"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -962,10 +1156,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "de1de2aa",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "model.fit(train[fcols], train['l'])"
    ]
@@ -973,8 +1169,22 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "0ca6204e",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "model.fit(train[fcols], train['l'], verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "3969c0f6",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "accuracy_score(train['l'], model.predict(train[fcols]))"
    ]
@@ -982,12 +1192,40 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "7249bfc1",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "accuracy_score(train['l'], model(tf.convert_to_tensor(train[fcols], dtype=tf.float32), training=False).numpy())"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "579f7ea1",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "accuracy_score(test['l'], model.predict(test[fcols]))"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "89a41dfa",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "accuracy_score(test['l'], model(tf.convert_to_tensor(test[fcols], dtype=tf.float32), training=False).numpy())"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -1054,8 +1292,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -1072,4 +1310,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/02_superintelligence.ipynb b/02_superintelligence.ipynb
index b3f2d97..958fd64 100755
--- a/02_superintelligence.ipynb
+++ b/02_superintelligence.ipynb
@@ -32,8 +32,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -208,13 +208,27 @@
     "tf.random.set_seed(100)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "7ec0d249",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "from tensorflow.python.framework.ops import disable_eager_execution\n",
+    "#disable_eager_execution()"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "aadf39bf",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "from tensorflow.python.framework.ops import disable_eager_execution\n",
     "#disable_eager_execution()"
    ]
   },
@@ -273,19 +287,43 @@
     "res.plot(figsize=(10, 6), style='--');"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "3f0c0d71",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "def epoch():\n",
+    "    print('|', end='')\n",
+    "    done = False\n",
+    "    state = env.reset()[0]\n",
+    "    treward = 1\n",
+    "    while not done:\n",
+    "        action = np.where(model.predict(np.atleast_2d(state), verbose=0)[0][0] > 0.5, 1, 0)\n",
+    "        state, reward, done, trunc, info = env.step(action)\n",
+    "        treward += reward if not done else 0\n",
+    "    return treward"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "24f13a24",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "def epoch():\n",
     "    print('|', end='')\n",
     "    done = False\n",
     "    state = env.reset()[0]\n",
     "    treward = 1\n",
     "    while not done:\n",
-    "        action = np.where(model.predict(np.atleast_2d(state), verbose=0)[0][0] > 0.5, 1, 0)\n",
+    "        action = np.where(model(tf.convert_to_tensor(np.atleast_2d(state, dtype=tf.float32), training=False).numpy(), verbose=0)[0][0] > 0.5, 1, 0)\n",
     "        state, reward, done, trunc, info = env.step(action)\n",
     "        treward += reward if not done else 0\n",
     "    return treward"
@@ -333,8 +371,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -351,4 +389,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/05_machine_learning.ipynb b/05_machine_learning.ipynb
index 0d9a056..fcdcd2a 100644
--- a/05_machine_learning.ipynb
+++ b/05_machine_learning.ipynb
@@ -1,1204 +1,1269 @@
 {
-  "cells": [
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "Ls9yXCvpZeoo"
-      },
-      "source": [
-        "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "X7IPp8mFZeoq"
-      },
-      "source": [
-        "# Artificial Intelligence in Finance"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "elMXud5zZeor"
-      },
-      "source": [
-        "## Machine Learning"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "DZ_Ox0HXZeos"
-      },
-      "source": [
-        "Dr Yves J Hilpisch | The AI Machine\n",
-        "\n",
-        "http://aimachine.io | http://twitter.com/dyjh"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "16e8wlQuZeou"
-      },
-      "source": [
-        "## Learning"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "6xZ5YTqcZeov"
-      },
-      "source": [
-        "<blockquote>\"A computer program is said to learn from experience ùê∏ with respect to some class of tasks ùëá and performance measure ùëÉ, if its performance at tasks in ùëá, as measured by ùëÉ, improves with experience ùê∏.\" ‚Äî Mitchell (1997)</blockquote>\n"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "9DaqSgbTZeov"
-      },
-      "source": [
-        "## Data"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "5qghZXCTZeow"
-      },
-      "execution_count": null,
-      "outputs": [],
-      "source": [
-        "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
-        "import sys\n",
-        "sys.path.append('ai_in_finance_book')\n"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "source": [
-        "!pip install -U scikit-learn==1.5.2"
-      ],
-      "metadata": {
-        "id": "MtxPfGwnlE_Y"
-      },
-      "execution_count": null,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "source": [
-        "#!pip install scikeras"
-      ],
-      "metadata": {
-        "id": "A_t7KDync17X"
-      },
-      "execution_count": null,
-      "outputs": []
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "6oXrAZCDZeox"
-      },
-      "outputs": [],
-      "source": [
-        "import numpy as np\n",
-        "import pandas as pd\n",
-        "from pylab import plt, mpl\n",
-        "np.random.seed(100)\n",
-        "plt.style.use('seaborn-v0_8')\n",
-        "mpl.rcParams['savefig.dpi'] = 300\n",
-        "mpl.rcParams['font.family'] = 'serif'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "FSFTPEcFZeox"
-      },
-      "outputs": [],
-      "source": [
-        "url = 'http://hilpisch.com/aiif_eikon_eod_data.csv'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "vAfmp_BWZeoy"
-      },
-      "outputs": [],
-      "source": [
-        "raw = pd.read_csv(url, index_col=0, parse_dates=True)['EUR=']"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "MQRuaVOzZeoy"
-      },
-      "outputs": [],
-      "source": [
-        "raw.head()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Baod2MIXZeoy"
-      },
-      "outputs": [],
-      "source": [
-        "raw.tail()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "8EKUc_1YZeoz"
-      },
-      "outputs": [],
-      "source": [
-        "l = raw.resample('1M').last()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "yoxfMBFcZeoz"
-      },
-      "outputs": [],
-      "source": [
-        "l.tail()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "VsXXLvMnZeoz"
-      },
-      "outputs": [],
-      "source": [
-        "l.plot(figsize=(10, 6), title='EUR/USD monthly');"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LfLwxHPHZeo0"
-      },
-      "outputs": [],
-      "source": [
-        "l = l.values\n",
-        "l -= l.mean()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "IxIA32XZZeo0"
-      },
-      "outputs": [],
-      "source": [
-        "f = np.linspace(-2, 2, len(l))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "8bvPqdB3Zeo0"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f, l, 'ro')\n",
-        "plt.title('Sample Data Set')\n",
-        "plt.xlabel('features')\n",
-        "plt.ylabel('labels');"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "pavggFAPZeo0"
-      },
-      "source": [
-        "## Success"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LmYyInRlZeo0"
-      },
-      "outputs": [],
-      "source": [
-        "def MSE(l, p):\n",
-        "    return np.mean((l - p) ** 2)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "u6UwNJmnZeo0"
-      },
-      "outputs": [],
-      "source": [
-        "reg = np.polyfit(f, l, deg=5)\n",
-        "reg"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "MDFLfRWXZeo1"
-      },
-      "outputs": [],
-      "source": [
-        "p = np.polyval(reg, f)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "lQZ1P8KKZeo1"
-      },
-      "outputs": [],
-      "source": [
-        "MSE(l, p)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "QsSDBSpWZeo1"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f, l, 'ro', label='sample data')\n",
-        "plt.plot(f, p, '--', label='regression')\n",
-        "plt.legend();"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "q6i1A1faZeo1"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "for i in range(10, len(f) + 1, 20):\n",
-        "    reg = np.polyfit(f[:i], l[:i], deg=3)\n",
-        "    p = np.polyval(reg, f)\n",
-        "    mse = MSE(l, p)\n",
-        "    print(f'{i:3d} | MSE={mse}')"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "YLXvFfqGZeo2"
-      },
-      "outputs": [],
-      "source": [
-        "import os\n",
-        "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '6'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LgKxboofZeo2"
-      },
-      "outputs": [],
-      "source": [
-        "import tensorflow as tf\n",
-        "from tensorflow import keras\n",
-        "tf.random.set_seed(100)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "jRP5NJbzZeo3"
-      },
-      "outputs": [],
-      "source": [
-        "from keras.layers import Dense\n",
-        "from keras.models import Sequential"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "95Is178pZepA"
-      },
-      "outputs": [],
-      "source": [
-        "model = Sequential()\n",
-        "model.add(Dense(256, activation='relu', input_dim=1))\n",
-        "model.add(Dense(1, activation='linear'))\n",
-        "model.compile(loss='mse', optimizer='rmsprop')"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "mCf3Sq5tZepA"
-      },
-      "outputs": [],
-      "source": [
-        "model.summary()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "eovFpOPJZepB"
-      },
-      "outputs": [],
-      "source": [
-        "%time hist = model.fit(f, l, epochs=1500, verbose=False)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "baQxPwYYZepC"
-      },
-      "outputs": [],
-      "source": [
-        "p = model.predict(f).flatten()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "la68yK2YZepC"
-      },
-      "outputs": [],
-      "source": [
-        "MSE(l, p)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "6_rQrMc9ZepC"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f, l, 'ro', label='sample data')\n",
-        "plt.plot(f, p, '--', label='DNN approximation')\n",
-        "plt.legend();"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "qxpvTZHZZepC"
-      },
-      "outputs": [],
-      "source": [
-        "import pandas as pd"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "hcIk8HkLZepC"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "QPRPFB35ZepD"
-      },
-      "outputs": [],
-      "source": [
-        "res.tail()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LsGcDGgdZepD"
-      },
-      "outputs": [],
-      "source": [
-        "res.iloc[100:].plot(figsize=(10, 6))\n",
-        "plt.ylabel('MSE')\n",
-        "plt.xlabel('epochs');"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "zOMZDwETZepD"
-      },
-      "source": [
-        "## Capacity"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "B5yciluzZepD"
-      },
-      "outputs": [],
-      "source": [
-        "reg = {}\n",
-        "for d in range(1, 12, 2):\n",
-        "    reg[d] = np.polyfit(f, l, deg=d)\n",
-        "    p = np.polyval(reg[d], f)\n",
-        "    mse = MSE(l, p)\n",
-        "    print(f'{d:2d} | MSE={mse}')"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "56yQJB0bZepD"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f, l, 'ro', label='sample data')\n",
-        "for d in reg:\n",
-        "    p = np.polyval(reg[d], f)\n",
-        "    plt.plot(f, p, '--', label=f'deg={d}')\n",
-        "plt.legend();"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "wk4LxmeJZepD"
-      },
-      "outputs": [],
-      "source": [
-        "def create_dnn_model(hl=1, hu=256):\n",
-        "    ''' Function to create Keras DNN model.\n",
-        "\n",
-        "    Parameters\n",
-        "    ==========\n",
-        "    hl: int\n",
-        "        number of hidden layers\n",
-        "    hu: int\n",
-        "        number of hidden units (per layer)\n",
-        "    '''\n",
-        "    model = Sequential()\n",
-        "    for _ in range(hl):\n",
-        "        model.add(Dense(hu, activation='relu', input_dim=1))\n",
-        "    model.add(Dense(1, activation='linear'))\n",
-        "    model.compile(loss='mse', optimizer='rmsprop')\n",
-        "    return model"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "2jVQOa6gZepD"
-      },
-      "outputs": [],
-      "source": [
-        "model = create_dnn_model(3)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "-UChZku4ZepD"
-      },
-      "outputs": [],
-      "source": [
-        "model.summary()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "zSH3jOEiZepD"
-      },
-      "outputs": [],
-      "source": [
-        "%time model.fit(f, l, epochs=2500, verbose=False)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "tviOkRu3ZepF"
-      },
-      "outputs": [],
-      "source": [
-        "p = model.predict(f).flatten()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "kgvTTlvfZepF"
-      },
-      "outputs": [],
-      "source": [
-        "MSE(l, p)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "t8Ll8NERZepF"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f, l, 'r', label='sample data')\n",
-        "plt.plot(f, p, '--', label='DNN approximation')\n",
-        "plt.legend();"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "5hN7PjbKZepF"
-      },
-      "source": [
-        "## Evaluation"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "JOsCDvsyZepF"
-      },
-      "outputs": [],
-      "source": [
-        "te = int(0.25 * len(f))\n",
-        "va = int(0.25 * len(f))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "FAPhwESiZepF"
-      },
-      "outputs": [],
-      "source": [
-        "np.random.seed(100)\n",
-        "ind = np.arange(len(f))\n",
-        "np.random.shuffle(ind)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "G2jNcfp_ZepF"
-      },
-      "outputs": [],
-      "source": [
-        "ind_te = np.sort(ind[:te])\n",
-        "ind_va = np.sort(ind[te:te + va])\n",
-        "ind_tr = np.sort(ind[te + va:])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "8eg7x4XaZepF"
-      },
-      "outputs": [],
-      "source": [
-        "f_te = f[ind_te]\n",
-        "f_va = f[ind_va]\n",
-        "f_tr = f[ind_tr]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Z4zHonioZepG"
-      },
-      "outputs": [],
-      "source": [
-        "l_te = l[ind_te]\n",
-        "l_va = l[ind_va]\n",
-        "l_tr = l[ind_tr]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "PTVFN8VEZepH"
-      },
-      "outputs": [],
-      "source": [
-        "reg = {}\n",
-        "mse = {}\n",
-        "for d in range(1, 22, 4):\n",
-        "    reg[d] = np.polyfit(f_tr, l_tr, deg=d)\n",
-        "    p = np.polyval(reg[d], f_tr)\n",
-        "    mse_tr = MSE(l_tr, p)\n",
-        "    p = np.polyval(reg[d], f_va)\n",
-        "    mse_va = MSE(l_va, p)\n",
-        "    mse[d] = (mse_tr, mse_va)\n",
-        "    print(f'{d:2d} | MSE_tr={mse_tr:7.5f} | MSE_va={mse_va:7.5f}')"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "zazn5tzdZepH"
-      },
-      "outputs": [],
-      "source": [
-        "fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n",
-        "ax[0].plot(f_tr, l_tr, 'ro', label='training data')\n",
-        "ax[1].plot(f_va, l_va, 'go', label='validation data')\n",
-        "for d in reg:\n",
-        "    p = np.polyval(reg[d], f_tr)\n",
-        "    ax[0].plot(f_tr, p, '--', label=f'deg={d} (tr)')\n",
-        "    p = np.polyval(reg[d], f_va)\n",
-        "    plt.plot(f_va, p, '--', label=f'deg={d} (va)')\n",
-        "ax[0].legend()\n",
-        "ax[1].legend();"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "SX1pro7XZepI"
-      },
-      "outputs": [],
-      "source": [
-        "from keras.callbacks import EarlyStopping"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "80jQJN4FZepI"
-      },
-      "outputs": [],
-      "source": [
-        "model = create_dnn_model(2, 256)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "5wkHHLRUZepI"
-      },
-      "outputs": [],
-      "source": [
-        "callbacks = [EarlyStopping(monitor='loss',\n",
-        "                           patience=100,\n",
-        "                          restore_best_weights=True)]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "IezEEwGfZepI"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(f_tr, l_tr, epochs=3000, verbose=False,\n",
-        "          validation_data=(f_va, l_va),\n",
-        "          callbacks=callbacks)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LyCQlROeZepI"
-      },
-      "outputs": [],
-      "source": [
-        "fig, ax = plt.subplots(2, 1, sharex=True, figsize=(10, 8))\n",
-        "ax[0].plot(f_tr, l_tr, 'ro', label='training data')\n",
-        "p = model.predict(f_tr)\n",
-        "ax[0].plot(f_tr, p, '--', label=f'DNN (tr)')\n",
-        "ax[0].legend()\n",
-        "ax[1].plot(f_va, l_va, 'go', label='validation data')\n",
-        "p = model.predict(f_va)\n",
-        "ax[1].plot(f_va, p, '--', label=f'DNN (va)')\n",
-        "ax[1].legend();"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "qH6gmRsBZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "yIe1h-z_ZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "res.tail()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "ScJQY9qWZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "res.iloc[35::25].plot(figsize=(10, 6))\n",
-        "plt.ylabel('MSE')\n",
-        "plt.xlabel('epochs');"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "23riqMKlZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "p_ols = np.polyval(reg[5], f_te)\n",
-        "p_dnn = model.predict(f_te).flatten()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "l-4zJ6i6ZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "MSE(l_te, p_ols)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "p-xrbxpoZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "MSE(l_te, p_dnn)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "aXl1ZuSDZepJ"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f_te, l_te, 'ro', label='test data')\n",
-        "plt.plot(f_te, p_ols, '--', label='OLS prediction')\n",
-        "plt.plot(f_te, p_dnn, '-.', label='DNN prediction');\n",
-        "plt.legend();"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "LrmAR9_lZepJ"
-      },
-      "source": [
-        "## Bias & Variance"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "aKjw7VqAZepK"
-      },
-      "outputs": [],
-      "source": [
-        "f_tr = f[:20:2]\n",
-        "l_tr = l[:20:2]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "q6Rmgf0KZepK"
-      },
-      "outputs": [],
-      "source": [
-        "f_va = f[1:20:2]\n",
-        "l_va = l[1:20:2]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "hEpSl4E8ZepK"
-      },
-      "outputs": [],
-      "source": [
-        "reg_b = np.polyfit(f_tr, l_tr, deg=1)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "4vlaSlXBZepK"
-      },
-      "outputs": [],
-      "source": [
-        "reg_v = np.polyfit(f_tr, l_tr, deg=9, full=True)[0]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "lRY2W9WfZepK"
-      },
-      "outputs": [],
-      "source": [
-        "f_ = np.linspace(f_tr.min(), f_va.max(), 75)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "RCOfPrGLZepL"
-      },
-      "outputs": [],
-      "source": [
-        "plt.figure(figsize=(10, 6))\n",
-        "plt.plot(f_tr, l_tr, 'ro', label='training data')\n",
-        "plt.plot(f_va, l_va, 'go', label='validation data')\n",
-        "plt.plot(f_, np.polyval(reg_b, f_), '--', label='high bias')\n",
-        "plt.plot(f_, np.polyval(reg_v, f_), '--', label='high variance')\n",
-        "plt.ylim(-0.2)\n",
-        "plt.legend(loc=2);"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "YquU2nfkZepL"
-      },
-      "outputs": [],
-      "source": [
-        "from sklearn.metrics import r2_score"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "5ntGz-CTZepL"
-      },
-      "outputs": [],
-      "source": [
-        "def evaluate(reg, f, l):\n",
-        "    p = np.polyval(reg, f)\n",
-        "    bias = np.abs(l - p).mean()\n",
-        "    var = p.var()\n",
-        "    msg = f'MSE={MSE(l, p):.4f} | R2={r2_score(l, p):9.4f} | '\n",
-        "    msg += f'bias={bias:.4f} | var={var:.4f}'\n",
-        "    print(msg)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "9Lim1YGnZepM"
-      },
-      "outputs": [],
-      "source": [
-        "evaluate(reg_b, f_tr, l_tr)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "a7f8Ep6NZepM"
-      },
-      "outputs": [],
-      "source": [
-        "evaluate(reg_b, f_va, l_va)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "2QuqUPUxZepM"
-      },
-      "outputs": [],
-      "source": [
-        "evaluate(reg_v, f_tr, l_tr)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "uj-7GMT0ZepM"
-      },
-      "outputs": [],
-      "source": [
-        "evaluate(reg_v, f_va, l_va)"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "lN5GX483ZepM"
-      },
-      "source": [
-        "## Cross-Validation"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "vWojKTA4ZepN"
-      },
-      "outputs": [],
-      "source": [
-        "from sklearn.model_selection import cross_val_score\n",
-        "from sklearn.preprocessing import PolynomialFeatures\n",
-        "from sklearn.linear_model import LinearRegression\n",
-        "from sklearn.pipeline import make_pipeline"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "44kK0YlPZepN"
-      },
-      "outputs": [],
-      "source": [
-        "def PolynomialRegression(degree=None, **kwargs):\n",
-        "    return make_pipeline(PolynomialFeatures(degree),\n",
-        "                        LinearRegression(**kwargs))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "1Z_IyjHQZepN"
-      },
-      "outputs": [],
-      "source": [
-        "np.set_printoptions(suppress=True,\n",
-        "        formatter={'float': lambda x: f'{x:12.2f}'})"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "HbHdR-qcZepN"
-      },
-      "outputs": [],
-      "source": [
-        "print('\\nCross-validation scores')\n",
-        "print(74 * '=')\n",
-        "for deg in range(0, 10, 1):\n",
-        "    model = PolynomialRegression(deg)\n",
-        "    cvs = cross_val_score(model, f.reshape(-1, 1), l, cv=5)\n",
-        "    print(f'deg={deg} | ' + str(cvs.round(2)))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "HU5OuJ80ZepO"
-      },
-      "outputs": [],
-      "source": [
-        "np.random.seed(100)\n",
-        "tf.random.set_seed(100)\n",
-        "#from keras.wrappers.scikit_learn import KerasRegressor\n",
-        "from scikeras.wrappers import KerasRegressor"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "3sUOHeHvZepP"
-      },
-      "outputs": [],
-      "source": [
-        "model=create_dnn_model\n",
-        "model = KerasRegressor(model=model,\n",
-        "                      verbose=False, epochs=1000,\n",
-        "                      hl=1, hu=36)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "V8xUHNscZepP"
-      },
-      "outputs": [],
-      "source": [
-        "%time cross_val_score(model, f.reshape(-1, 1), l, cv=5)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "81UWAIfgZepP"
-      },
-      "outputs": [],
-      "source": [
-        "help(KerasRegressor)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "W8hB8clPZepQ"
-      },
-      "outputs": [],
-      "source": [
-        "model = KerasRegressor(model=create_dnn_model,\n",
-        "                      verbose=False, epochs=1000,\n",
-        "                      hl=3, hu=256)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "XABfb4IfZepQ"
-      },
-      "outputs": [],
-      "source": [
-        "%time cross_val_score(model, f.reshape(-1, 1), l, cv=5)"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "LQdrZeoVZepQ"
-      },
-      "source": [
-        "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">\n",
-        "\n",
-        "<br><br><br><a href=\"http://tpq.io\" target=\"_blank\">http://tpq.io</a> | <a href=\"http://twitter.com/dyjh\" target=\"_blank\">@dyjh</a> | <a href=\"mailto:ai@tpq.io\">ai@tpq.io</a>"
-      ]
-    }
-  ],
-  "metadata": {
-    "kernelspec": {
-      "name": "python3",
-      "display_name": "Python 3"
-    },
-    "language_info": {
-      "codemirror_mode": {
-        "name": "ipython",
-        "version": 3
-      },
-      "file_extension": ".py",
-      "mimetype": "text/x-python",
-      "name": "python",
-      "nbconvert_exporter": "python",
-      "pygments_lexer": "ipython3",
-      "version": "3.10.13"
-    },
-    "colab": {
-      "provenance": []
-    }
-  },
-  "nbformat": 4,
-  "nbformat_minor": 0
-}
\ No newline at end of file
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "Ls9yXCvpZeoo"
+   },
+   "source": [
+    "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "X7IPp8mFZeoq"
+   },
+   "source": [
+    "# Artificial Intelligence in Finance"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "elMXud5zZeor"
+   },
+   "source": [
+    "## Machine Learning"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "DZ_Ox0HXZeos"
+   },
+   "source": [
+    "Dr Yves J Hilpisch | The AI Machine\n",
+    "\n",
+    "http://aimachine.io | http://twitter.com/dyjh"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "16e8wlQuZeou"
+   },
+   "source": [
+    "## Learning"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "6xZ5YTqcZeov"
+   },
+   "source": [
+    "<blockquote>\"A computer program is said to learn from experience ùê∏ with respect to some class of tasks ùëá and performance measure ùëÉ, if its performance at tasks in ùëá, as measured by ùëÉ, improves with experience ùê∏.\" ‚Äî Mitchell (1997)</blockquote>\n"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "9DaqSgbTZeov"
+   },
+   "source": [
+    "## Data"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "5qghZXCTZeow"
+   },
+   "outputs": [],
+   "source": [
+    "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
+    "import sys\n",
+    "sys.path.append('ai_in_finance_book')\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "MtxPfGwnlE_Y"
+   },
+   "outputs": [],
+   "source": [
+    "!pip install -U scikit-learn==1.5.2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "A_t7KDync17X"
+   },
+   "outputs": [],
+   "source": [
+    "#!pip install scikeras"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "6oXrAZCDZeox"
+   },
+   "outputs": [],
+   "source": [
+    "import numpy as np\n",
+    "import pandas as pd\n",
+    "from pylab import plt, mpl\n",
+    "np.random.seed(100)\n",
+    "plt.style.use('seaborn-v0_8')\n",
+    "mpl.rcParams['savefig.dpi'] = 300\n",
+    "mpl.rcParams['font.family'] = 'serif'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "FSFTPEcFZeox"
+   },
+   "outputs": [],
+   "source": [
+    "url = 'http://hilpisch.com/aiif_eikon_eod_data.csv'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "vAfmp_BWZeoy"
+   },
+   "outputs": [],
+   "source": [
+    "raw = pd.read_csv(url, index_col=0, parse_dates=True)['EUR=']"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "MQRuaVOzZeoy"
+   },
+   "outputs": [],
+   "source": [
+    "raw.head()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Baod2MIXZeoy"
+   },
+   "outputs": [],
+   "source": [
+    "raw.tail()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "8EKUc_1YZeoz"
+   },
+   "outputs": [],
+   "source": [
+    "l = raw.resample('1M').last()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "yoxfMBFcZeoz"
+   },
+   "outputs": [],
+   "source": [
+    "l.tail()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "VsXXLvMnZeoz"
+   },
+   "outputs": [],
+   "source": [
+    "l.plot(figsize=(10, 6), title='EUR/USD monthly');"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "LfLwxHPHZeo0"
+   },
+   "outputs": [],
+   "source": [
+    "l = l.values\n",
+    "l -= l.mean()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "IxIA32XZZeo0"
+   },
+   "outputs": [],
+   "source": [
+    "f = np.linspace(-2, 2, len(l))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "8bvPqdB3Zeo0"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f, l, 'ro')\n",
+    "plt.title('Sample Data Set')\n",
+    "plt.xlabel('features')\n",
+    "plt.ylabel('labels');"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "pavggFAPZeo0"
+   },
+   "source": [
+    "## Success"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "LmYyInRlZeo0"
+   },
+   "outputs": [],
+   "source": [
+    "def MSE(l, p):\n",
+    "    return np.mean((l - p) ** 2)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "u6UwNJmnZeo0"
+   },
+   "outputs": [],
+   "source": [
+    "reg = np.polyfit(f, l, deg=5)\n",
+    "reg"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "MDFLfRWXZeo1"
+   },
+   "outputs": [],
+   "source": [
+    "p = np.polyval(reg, f)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "lQZ1P8KKZeo1"
+   },
+   "outputs": [],
+   "source": [
+    "MSE(l, p)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "QsSDBSpWZeo1"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f, l, 'ro', label='sample data')\n",
+    "plt.plot(f, p, '--', label='regression')\n",
+    "plt.legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "q6i1A1faZeo1"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "for i in range(10, len(f) + 1, 20):\n",
+    "    reg = np.polyfit(f[:i], l[:i], deg=3)\n",
+    "    p = np.polyval(reg, f)\n",
+    "    mse = MSE(l, p)\n",
+    "    print(f'{i:3d} | MSE={mse}')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "YLXvFfqGZeo2"
+   },
+   "outputs": [],
+   "source": [
+    "import os\n",
+    "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '6'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "LgKxboofZeo2"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "from tensorflow import keras\n",
+    "tf.random.set_seed(100)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "jRP5NJbzZeo3"
+   },
+   "outputs": [],
+   "source": [
+    "from keras.layers import Dense\n",
+    "from keras.models import Sequential"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "95Is178pZepA"
+   },
+   "outputs": [],
+   "source": [
+    "model = Sequential()\n",
+    "model.add(Dense(256, activation='relu', input_dim=1))\n",
+    "model.add(Dense(1, activation='linear'))\n",
+    "model.compile(loss='mse', optimizer='rmsprop')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "mCf3Sq5tZepA"
+   },
+   "outputs": [],
+   "source": [
+    "model.summary()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "eovFpOPJZepB"
+   },
+   "outputs": [],
+   "source": [
+    "%time hist = model.fit(f, l, epochs=1500, verbose=False)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "50c6a740",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "baQxPwYYZepC"
+   },
+   "source": [
+    "p = model.predict(f).flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "06d220c8",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "p = model(tf.convert_to_tensor(f, dtype=tf.float32), training=False).numpy().flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "la68yK2YZepC"
+   },
+   "outputs": [],
+   "source": [
+    "MSE(l, p)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "6_rQrMc9ZepC"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f, l, 'ro', label='sample data')\n",
+    "plt.plot(f, p, '--', label='DNN approximation')\n",
+    "plt.legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "qxpvTZHZZepC"
+   },
+   "outputs": [],
+   "source": [
+    "import pandas as pd"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "hcIk8HkLZepC"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "QPRPFB35ZepD"
+   },
+   "outputs": [],
+   "source": [
+    "res.tail()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "LsGcDGgdZepD"
+   },
+   "outputs": [],
+   "source": [
+    "res.iloc[100:].plot(figsize=(10, 6))\n",
+    "plt.ylabel('MSE')\n",
+    "plt.xlabel('epochs');"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "zOMZDwETZepD"
+   },
+   "source": [
+    "## Capacity"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "B5yciluzZepD"
+   },
+   "outputs": [],
+   "source": [
+    "reg = {}\n",
+    "for d in range(1, 12, 2):\n",
+    "    reg[d] = np.polyfit(f, l, deg=d)\n",
+    "    p = np.polyval(reg[d], f)\n",
+    "    mse = MSE(l, p)\n",
+    "    print(f'{d:2d} | MSE={mse}')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "56yQJB0bZepD"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f, l, 'ro', label='sample data')\n",
+    "for d in reg:\n",
+    "    p = np.polyval(reg[d], f)\n",
+    "    plt.plot(f, p, '--', label=f'deg={d}')\n",
+    "plt.legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "wk4LxmeJZepD"
+   },
+   "outputs": [],
+   "source": [
+    "def create_dnn_model(hl=1, hu=256):\n",
+    "    ''' Function to create Keras DNN model.\n",
+    "\n",
+    "    Parameters\n",
+    "    ==========\n",
+    "    hl: int\n",
+    "        number of hidden layers\n",
+    "    hu: int\n",
+    "        number of hidden units (per layer)\n",
+    "    '''\n",
+    "    model = Sequential()\n",
+    "    for _ in range(hl):\n",
+    "        model.add(Dense(hu, activation='relu', input_dim=1))\n",
+    "    model.add(Dense(1, activation='linear'))\n",
+    "    model.compile(loss='mse', optimizer='rmsprop')\n",
+    "    return model"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "2jVQOa6gZepD"
+   },
+   "outputs": [],
+   "source": [
+    "model = create_dnn_model(3)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "-UChZku4ZepD"
+   },
+   "outputs": [],
+   "source": [
+    "model.summary()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "zSH3jOEiZepD"
+   },
+   "outputs": [],
+   "source": [
+    "%time model.fit(f, l, epochs=2500, verbose=False)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "13d76ed3",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "tviOkRu3ZepF"
+   },
+   "source": [
+    "p = model.predict(f).flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "05ea780d",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "p = model(tf.convert_to_tensor(f, dtype=tf.float32), training=False).numpy().flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "kgvTTlvfZepF"
+   },
+   "outputs": [],
+   "source": [
+    "MSE(l, p)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "t8Ll8NERZepF"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f, l, 'r', label='sample data')\n",
+    "plt.plot(f, p, '--', label='DNN approximation')\n",
+    "plt.legend();"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "5hN7PjbKZepF"
+   },
+   "source": [
+    "## Evaluation"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "JOsCDvsyZepF"
+   },
+   "outputs": [],
+   "source": [
+    "te = int(0.25 * len(f))\n",
+    "va = int(0.25 * len(f))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "FAPhwESiZepF"
+   },
+   "outputs": [],
+   "source": [
+    "np.random.seed(100)\n",
+    "ind = np.arange(len(f))\n",
+    "np.random.shuffle(ind)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "G2jNcfp_ZepF"
+   },
+   "outputs": [],
+   "source": [
+    "ind_te = np.sort(ind[:te])\n",
+    "ind_va = np.sort(ind[te:te + va])\n",
+    "ind_tr = np.sort(ind[te + va:])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "8eg7x4XaZepF"
+   },
+   "outputs": [],
+   "source": [
+    "f_te = f[ind_te]\n",
+    "f_va = f[ind_va]\n",
+    "f_tr = f[ind_tr]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Z4zHonioZepG"
+   },
+   "outputs": [],
+   "source": [
+    "l_te = l[ind_te]\n",
+    "l_va = l[ind_va]\n",
+    "l_tr = l[ind_tr]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "PTVFN8VEZepH"
+   },
+   "outputs": [],
+   "source": [
+    "reg = {}\n",
+    "mse = {}\n",
+    "for d in range(1, 22, 4):\n",
+    "    reg[d] = np.polyfit(f_tr, l_tr, deg=d)\n",
+    "    p = np.polyval(reg[d], f_tr)\n",
+    "    mse_tr = MSE(l_tr, p)\n",
+    "    p = np.polyval(reg[d], f_va)\n",
+    "    mse_va = MSE(l_va, p)\n",
+    "    mse[d] = (mse_tr, mse_va)\n",
+    "    print(f'{d:2d} | MSE_tr={mse_tr:7.5f} | MSE_va={mse_va:7.5f}')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "zazn5tzdZepH"
+   },
+   "outputs": [],
+   "source": [
+    "fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n",
+    "ax[0].plot(f_tr, l_tr, 'ro', label='training data')\n",
+    "ax[1].plot(f_va, l_va, 'go', label='validation data')\n",
+    "for d in reg:\n",
+    "    p = np.polyval(reg[d], f_tr)\n",
+    "    ax[0].plot(f_tr, p, '--', label=f'deg={d} (tr)')\n",
+    "    p = np.polyval(reg[d], f_va)\n",
+    "    plt.plot(f_va, p, '--', label=f'deg={d} (va)')\n",
+    "ax[0].legend()\n",
+    "ax[1].legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "SX1pro7XZepI"
+   },
+   "outputs": [],
+   "source": [
+    "from keras.callbacks import EarlyStopping"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "80jQJN4FZepI"
+   },
+   "outputs": [],
+   "source": [
+    "model = create_dnn_model(2, 256)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "5wkHHLRUZepI"
+   },
+   "outputs": [],
+   "source": [
+    "callbacks = [EarlyStopping(monitor='loss',\n",
+    "                           patience=100,\n",
+    "                          restore_best_weights=True)]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "IezEEwGfZepI"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(f_tr, l_tr, epochs=3000, verbose=False,\n",
+    "          validation_data=(f_va, l_va),\n",
+    "          callbacks=callbacks)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "43063f3f",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "LyCQlROeZepI"
+   },
+   "source": [
+    "fig, ax = plt.subplots(2, 1, sharex=True, figsize=(10, 8))\n",
+    "ax[0].plot(f_tr, l_tr, 'ro', label='training data')\n",
+    "p = model.predict(f_tr)\n",
+    "ax[0].plot(f_tr, p, '--', label=f'DNN (tr)')\n",
+    "ax[0].legend()\n",
+    "ax[1].plot(f_va, l_va, 'go', label='validation data')\n",
+    "p = model.predict(f_va)\n",
+    "ax[1].plot(f_va, p, '--', label=f'DNN (va)')\n",
+    "ax[1].legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "d641cb22",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "fig, ax = plt.subplots(2, 1, sharex=True, figsize=(10, 8))\n",
+    "ax[0].plot(f_tr, l_tr, 'ro', label='training data')\n",
+    "p = model(tf.convert_to_tensor(f_tr, dtype=tf.float32), training=False).numpy()\n",
+    "ax[0].plot(f_tr, p, '--', label=f'DNN (tr)')\n",
+    "ax[0].legend()\n",
+    "ax[1].plot(f_va, l_va, 'go', label='validation data')\n",
+    "p = model(tf.convert_to_tensor(f_va, dtype=tf.float32), training=False).numpy()\n",
+    "ax[1].plot(f_va, p, '--', label=f'DNN (va)')\n",
+    "ax[1].legend();"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "qH6gmRsBZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "yIe1h-z_ZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "res.tail()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "ScJQY9qWZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "res.iloc[35::25].plot(figsize=(10, 6))\n",
+    "plt.ylabel('MSE')\n",
+    "plt.xlabel('epochs');"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "95cb5afe",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "23riqMKlZepJ"
+   },
+   "source": [
+    "p_ols = np.polyval(reg[5], f_te)\n",
+    "p_dnn = model.predict(f_te).flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "265076d9",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "p_ols = np.polyval(reg[5], f_te)\n",
+    "p_dnn = model(tf.convert_to_tensor(f_te, dtype=tf.float32), training=False).numpy().flatten()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "l-4zJ6i6ZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "MSE(l_te, p_ols)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "p-xrbxpoZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "MSE(l_te, p_dnn)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "aXl1ZuSDZepJ"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f_te, l_te, 'ro', label='test data')\n",
+    "plt.plot(f_te, p_ols, '--', label='OLS prediction')\n",
+    "plt.plot(f_te, p_dnn, '-.', label='DNN prediction');\n",
+    "plt.legend();"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "LrmAR9_lZepJ"
+   },
+   "source": [
+    "## Bias & Variance"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "aKjw7VqAZepK"
+   },
+   "outputs": [],
+   "source": [
+    "f_tr = f[:20:2]\n",
+    "l_tr = l[:20:2]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "q6Rmgf0KZepK"
+   },
+   "outputs": [],
+   "source": [
+    "f_va = f[1:20:2]\n",
+    "l_va = l[1:20:2]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "hEpSl4E8ZepK"
+   },
+   "outputs": [],
+   "source": [
+    "reg_b = np.polyfit(f_tr, l_tr, deg=1)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "4vlaSlXBZepK"
+   },
+   "outputs": [],
+   "source": [
+    "reg_v = np.polyfit(f_tr, l_tr, deg=9, full=True)[0]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "lRY2W9WfZepK"
+   },
+   "outputs": [],
+   "source": [
+    "f_ = np.linspace(f_tr.min(), f_va.max(), 75)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "RCOfPrGLZepL"
+   },
+   "outputs": [],
+   "source": [
+    "plt.figure(figsize=(10, 6))\n",
+    "plt.plot(f_tr, l_tr, 'ro', label='training data')\n",
+    "plt.plot(f_va, l_va, 'go', label='validation data')\n",
+    "plt.plot(f_, np.polyval(reg_b, f_), '--', label='high bias')\n",
+    "plt.plot(f_, np.polyval(reg_v, f_), '--', label='high variance')\n",
+    "plt.ylim(-0.2)\n",
+    "plt.legend(loc=2);"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "YquU2nfkZepL"
+   },
+   "outputs": [],
+   "source": [
+    "from sklearn.metrics import r2_score"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "5ntGz-CTZepL"
+   },
+   "outputs": [],
+   "source": [
+    "def evaluate(reg, f, l):\n",
+    "    p = np.polyval(reg, f)\n",
+    "    bias = np.abs(l - p).mean()\n",
+    "    var = p.var()\n",
+    "    msg = f'MSE={MSE(l, p):.4f} | R2={r2_score(l, p):9.4f} | '\n",
+    "    msg += f'bias={bias:.4f} | var={var:.4f}'\n",
+    "    print(msg)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "9Lim1YGnZepM"
+   },
+   "outputs": [],
+   "source": [
+    "evaluate(reg_b, f_tr, l_tr)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "a7f8Ep6NZepM"
+   },
+   "outputs": [],
+   "source": [
+    "evaluate(reg_b, f_va, l_va)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "2QuqUPUxZepM"
+   },
+   "outputs": [],
+   "source": [
+    "evaluate(reg_v, f_tr, l_tr)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "uj-7GMT0ZepM"
+   },
+   "outputs": [],
+   "source": [
+    "evaluate(reg_v, f_va, l_va)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "lN5GX483ZepM"
+   },
+   "source": [
+    "## Cross-Validation"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "vWojKTA4ZepN"
+   },
+   "outputs": [],
+   "source": [
+    "from sklearn.model_selection import cross_val_score\n",
+    "from sklearn.preprocessing import PolynomialFeatures\n",
+    "from sklearn.linear_model import LinearRegression\n",
+    "from sklearn.pipeline import make_pipeline"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "44kK0YlPZepN"
+   },
+   "outputs": [],
+   "source": [
+    "def PolynomialRegression(degree=None, **kwargs):\n",
+    "    return make_pipeline(PolynomialFeatures(degree),\n",
+    "                        LinearRegression(**kwargs))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "1Z_IyjHQZepN"
+   },
+   "outputs": [],
+   "source": [
+    "np.set_printoptions(suppress=True,\n",
+    "        formatter={'float': lambda x: f'{x:12.2f}'})"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "HbHdR-qcZepN"
+   },
+   "outputs": [],
+   "source": [
+    "print('\\nCross-validation scores')\n",
+    "print(74 * '=')\n",
+    "for deg in range(0, 10, 1):\n",
+    "    model = PolynomialRegression(deg)\n",
+    "    cvs = cross_val_score(model, f.reshape(-1, 1), l, cv=5)\n",
+    "    print(f'deg={deg} | ' + str(cvs.round(2)))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "HU5OuJ80ZepO"
+   },
+   "outputs": [],
+   "source": [
+    "np.random.seed(100)\n",
+    "tf.random.set_seed(100)\n",
+    "#from keras.wrappers.scikit_learn import KerasRegressor\n",
+    "from scikeras.wrappers import KerasRegressor"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "3sUOHeHvZepP"
+   },
+   "outputs": [],
+   "source": [
+    "model=create_dnn_model\n",
+    "model = KerasRegressor(model=model,\n",
+    "                      verbose=False, epochs=1000,\n",
+    "                      hl=1, hu=36)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "V8xUHNscZepP"
+   },
+   "outputs": [],
+   "source": [
+    "%time cross_val_score(model, f.reshape(-1, 1), l, cv=5)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "81UWAIfgZepP"
+   },
+   "outputs": [],
+   "source": [
+    "help(KerasRegressor)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "W8hB8clPZepQ"
+   },
+   "outputs": [],
+   "source": [
+    "model = KerasRegressor(model=create_dnn_model,\n",
+    "                      verbose=False, epochs=1000,\n",
+    "                      hl=3, hu=256)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "XABfb4IfZepQ"
+   },
+   "outputs": [],
+   "source": [
+    "%time cross_val_score(model, f.reshape(-1, 1), l, cv=5)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "LQdrZeoVZepQ"
+   },
+   "source": [
+    "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">\n",
+    "\n",
+    "<br><br><br><a href=\"http://tpq.io\" target=\"_blank\">http://tpq.io</a> | <a href=\"http://twitter.com/dyjh\" target=\"_blank\">@dyjh</a> | <a href=\"mailto:ai@tpq.io\">ai@tpq.io</a>"
+   ]
+  }
+ ],
+ "metadata": {
+  "colab": {
+   "provenance": []
+  },
+  "kernelspec": {
+   "display_name": "Python 3",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.10.13"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 0
+}
diff --git a/06_ai_first_finance.ipynb b/06_ai_first_finance.ipynb
index 8cc1f02..e42ea45 100755
--- a/06_ai_first_finance.ipynb
+++ b/06_ai_first_finance.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -325,12 +325,39 @@
     "from sklearn.neural_network import MLPRegressor"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "bba5677c",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%%time\n",
+    "for sym in data.columns:\n",
+    "    df = dfs[sym]\n",
+    "    model = MLPRegressor(hidden_layer_sizes=[512],\n",
+    "                         random_state=100,\n",
+    "                         max_iter=1000,\n",
+    "                         early_stopping=True,\n",
+    "                         validation_fraction=0.15,\n",
+    "                         shuffle=False)\n",
+    "    model.fit(df[cols], df[sym])\n",
+    "    pred = model.predict(df[cols])\n",
+    "    acc = accuracy_score(np.sign(df[sym]), np.sign(pred))\n",
+    "    print(f'MLP | {sym:10s} | acc={acc:.4f}')"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "f1b9b286",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "%%time\n",
     "for sym in data.columns:\n",
     "    df = dfs[sym]\n",
@@ -340,8 +367,8 @@
     "                         early_stopping=True,\n",
     "                         validation_fraction=0.15,\n",
     "                         shuffle=False)\n",
-    "    model.fit(df[cols], df[sym])\n",
-    "    pred = model.predict(df[cols])\n",
+    "    model.fit(df[cols], df[sym], verbose=0)\n",
+    "    pred = model(tf.convert_to_tensor(df[cols], dtype=tf.float32), training=False).numpy()\n",
     "    acc = accuracy_score(np.sign(df[sym]), np.sign(pred))\n",
     "    print(f'MLP | {sym:10s} | acc={acc:.4f}')"
    ]
@@ -397,18 +424,40 @@
     "    return model"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "237ccca1",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%%time\n",
+    "for sym in data.columns[:]:\n",
+    "    df = dfs[sym]\n",
+    "    model = create_model()\n",
+    "    model.fit(df[cols], df[sym], epochs=25, verbose=False)\n",
+    "    pred = model.predict(df[cols])\n",
+    "    acc = accuracy_score(np.sign(df[sym]), np.sign(pred))\n",
+    "    print(f'DNN | {sym:10s} | acc={acc:.4f}')"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "6a6e46fc",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "%%time\n",
     "for sym in data.columns[:]:\n",
     "    df = dfs[sym]\n",
     "    model = create_model()\n",
     "    model.fit(df[cols], df[sym], epochs=25, verbose=False)\n",
-    "    pred = model.predict(df[cols])\n",
+    "    pred = model(tf.convert_to_tensor(df[cols], dtype=tf.float32), training=False).numpy()\n",
     "    acc = accuracy_score(np.sign(df[sym]), np.sign(pred))\n",
     "    print(f'DNN | {sym:10s} | acc={acc:.4f}')"
    ]
@@ -440,10 +489,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "c6328267",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "%%time\n",
     "for sym in data.columns:\n",
@@ -465,8 +516,37 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "a3d0c4d8",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "%%time\n",
+    "for sym in data.columns:\n",
+    "    df = dfs[sym]\n",
+    "    train = df.iloc[:split]\n",
+    "    model = MLPRegressor(hidden_layer_sizes=[512],\n",
+    "                         random_state=100,\n",
+    "                         max_iter=1000,\n",
+    "                         early_stopping=True,\n",
+    "                         validation_fraction=0.15,\n",
+    "                         shuffle=False)\n",
+    "    model.fit(train[cols], train[sym], verbose=0)\n",
+    "    test = df.iloc[split:]\n",
+    "    pred = model(tf.convert_to_tensor(test[cols], dtype=tf.float32), training=False).numpy()\n",
+    "    acc = accuracy_score(np.sign(test[sym]), np.sign(pred))\n",
+    "    print(f'MLP | {sym:10s} | acc={acc:.4f}')"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "b06dd96d",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "%%time\n",
     "for sym in data.columns:\n",
@@ -480,6 +560,28 @@
     "    print(f'DNN | {sym:10s} | acc={acc:.4f}')"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "b633b616",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "%%time\n",
+    "for sym in data.columns:\n",
+    "    df = dfs[sym]\n",
+    "    train = df.iloc[:split]\n",
+    "    model = create_model()\n",
+    "    model.fit(train[cols], train[sym], epochs=50, verbose=False)\n",
+    "    test = df.iloc[split:]\n",
+    "    pred = model(tf.convert_to_tensor(test[cols], dtype=tf.float32), training=False).numpy()\n",
+    "    acc = accuracy_score(np.sign(test[sym]), np.sign(pred))\n",
+    "    print(f'DNN | {sym:10s} | acc={acc:.4f}')"
+   ]
+  },
   {
    "cell_type": "markdown",
    "metadata": {},
@@ -573,10 +675,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "5405fdcb",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "%%time\n",
     "for ric in data:\n",
@@ -597,8 +701,36 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "8bd8bbb0",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "%%time\n",
+    "for ric in data:\n",
+    "    model = MLPClassifier(hidden_layer_sizes=[512],\n",
+    "                          random_state=100,\n",
+    "                          max_iter=1000,\n",
+    "                          early_stopping=True,\n",
+    "                          validation_fraction=0.15,\n",
+    "                          shuffle=False)\n",
+    "    df, cols = dfs[ric]\n",
+    "    df[cols] = (df[cols] - df[cols].mean()) / df[cols].std()\n",
+    "    model.fit(df[cols], df['d'], verbose=0)\n",
+    "    pred = model(tf.convert_to_tensor(df[cols], dtype=tf.float32), training=False).numpy()\n",
+    "    acc = accuracy_score(df['d'], pred)\n",
+    "    print(f'IN-SAMPLE | {ric:7s} | acc={acc:.4f}')"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "050582d4",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "%%time\n",
     "for ric in data:\n",
@@ -614,8 +746,31 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "f44c8d3d",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "%%time\n",
+    "for ric in data:\n",
+    "    model = create_model('classification')\n",
+    "    df, cols = dfs[ric]\n",
+    "    df[cols] = (df[cols] - df[cols].mean()) / df[cols].std()\n",
+    "    model.fit(df[cols], df['d'], epochs=50, verbose=False)\n",
+    "    pred = np.where(model(tf.convert_to_tensor(df[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)\n",
+    "    acc = accuracy_score(df['d'], pred)\n",
+    "    print(f'IN-SAMPLE | {ric:7s} | acc={acc:.4f}')"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "63891cca",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "def train_test_model(model):\n",
     "    for ric in data:\n",
@@ -632,6 +787,31 @@
     "        print(f'OUT-OF-SAMPLE | {ric:7s} | acc={acc:.4f}')"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "ba2de132",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "def train_test_model(model):\n",
+    "    for ric in data:\n",
+    "        df, cols = dfs[ric]\n",
+    "        split = int(len(df) * 0.85)\n",
+    "        train = df.iloc[:split].copy()\n",
+    "        mu, std = train[cols].mean(), train[cols].std()\n",
+    "        train[cols] = (train[cols] - mu) / std\n",
+    "        model.fit(train[cols], train['d'], verbose=0)\n",
+    "        test = df.iloc[split:].copy() \n",
+    "        test[cols] = (test[cols] - mu) / std\n",
+    "        pred = model(tf.convert_to_tensor(test[cols], dtype=tf.float32), training=False).numpy()\n",
+    "        acc = accuracy_score(test['d'], pred)\n",
+    "        print(f'OUT-OF-SAMPLE | {ric:7s} | acc={acc:.4f}')"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -798,8 +978,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -816,4 +996,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/07_dense_networks.ipynb b/07_dense_networks.ipynb
index 0445dcf..b3fb42a 100644
--- a/07_dense_networks.ipynb
+++ b/07_dense_networks.ipynb
@@ -1,1504 +1,1556 @@
 {
-  "cells": [
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "ZSGtiUGQwat-"
-      },
-      "source": [
-        "<img src=\"https://certificate.tpq.io/taim_logo.png\" width=\"350px\" align=\"right\">"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "GnFAhJjdwauA"
-      },
-      "source": [
-        "# Artificial Intelligence in Finance"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "HHRFGXFFwauB"
-      },
-      "source": [
-        "## Dense Neural Networks"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "vmIykJO_wauC"
-      },
-      "source": [
-        "Dr Yves J Hilpisch | The AI Machine\n",
-        "\n",
-        "http://aimachine.io | http://twitter.com/dyjh"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "metadata": {
-        "id": "DIX7mDDfwauD"
-      },
-      "execution_count": null,
-      "outputs": [],
-      "source": [
-        "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
-        "import sys\n",
-        "sys.path.append('ai_in_finance_book')\n"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Bh2-JIy6wauF"
-      },
-      "outputs": [],
-      "source": [
-        "import os\n",
-        "import numpy as np\n",
-        "import pandas as pd\n",
-        "from pylab import plt, mpl\n",
-        "plt.style.use('seaborn-v0_8')\n",
-        "mpl.rcParams['savefig.dpi'] = 300\n",
-        "mpl.rcParams['font.family'] = 'serif'\n",
-        "pd.set_option('display.precision', 4)\n",
-        "np.set_printoptions(suppress=True, precision=4)\n",
-        "os.environ['PYTHONHASHSEED'] = '0'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "source": [
-        "!pip install scikeras"
-      ],
-      "metadata": {
-        "id": "TFuNPCAyU5-9"
-      },
-      "execution_count": null,
-      "outputs": []
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "cj4aX2uWwauF"
-      },
-      "source": [
-        "## The Data"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "O4JqsE3uwauI"
-      },
-      "outputs": [],
-      "source": [
-        "url = 'http://hilpisch.com/aiif_eikon_id_eur_usd.csv'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Mlq_qkguwauJ"
-      },
-      "outputs": [],
-      "source": [
-        "symbol = 'EUR_USD'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "KXSofZY0wauK"
-      },
-      "outputs": [],
-      "source": [
-        "raw = pd.read_csv(url, index_col=0, parse_dates=True)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "vqbKPIZgwauK"
-      },
-      "outputs": [],
-      "source": [
-        "raw.head()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "8vy9cj0UwauL"
-      },
-      "outputs": [],
-      "source": [
-        "raw.info()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "JbOxVpNpwauL"
-      },
-      "outputs": [],
-      "source": [
-        "data = pd.DataFrame(raw['CLOSE'].loc[:])\n",
-        "data.columns = [symbol]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "cMsWk-P1wauL"
-      },
-      "outputs": [],
-      "source": [
-        "data = data.resample('1h', label='right').last().ffill()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "XpuuFJuzwauM"
-      },
-      "outputs": [],
-      "source": [
-        "data.info()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "u7zB4kZ_wauM"
-      },
-      "outputs": [],
-      "source": [
-        "data.plot(figsize=(10, 6));"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "-x2nsck2wauM"
-      },
-      "source": [
-        "## Baseline Prediction"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "7MGAhH3xwauM"
-      },
-      "outputs": [],
-      "source": [
-        "lags = 5"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "JkaOKhWJwauM"
-      },
-      "outputs": [],
-      "source": [
-        "def add_lags(data, symbol, lags, window=20):\n",
-        "    cols = []\n",
-        "    df = data.copy()\n",
-        "    df.dropna(inplace=True)\n",
-        "    df['r'] = np.log(df / df.shift())\n",
-        "    df['sma'] = df[symbol].rolling(window).mean()\n",
-        "    df['min'] = df[symbol].rolling(window).min()\n",
-        "    df['max'] = df[symbol].rolling(window).max()\n",
-        "    df['mom'] = df['r'].rolling(window).mean()\n",
-        "    df['vol'] = df['r'].rolling(window).std()\n",
-        "    df.dropna(inplace=True)\n",
-        "    df['d'] = np.where(df['r'] > 0, 1, 0)\n",
-        "    features = [symbol, 'r', 'd', 'sma', 'min', 'max', 'mom', 'vol']\n",
-        "    for f in features:\n",
-        "        for lag in range(1, lags + 1):\n",
-        "            col = f'{f}_lag_{lag}'\n",
-        "            df[col] = df[f].shift(lag)\n",
-        "            cols.append(col)\n",
-        "    df.dropna(inplace=True)\n",
-        "    return df, cols"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "LDCaFzJ2wauN"
-      },
-      "outputs": [],
-      "source": [
-        "data, cols = add_lags(data, symbol, lags)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "GOkyHK4ywauN"
-      },
-      "outputs": [],
-      "source": [
-        "len(data)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "_Yqtqo59wauN"
-      },
-      "outputs": [],
-      "source": [
-        "# data.iloc[:10, :14].round(4)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "wEcYt9PJwauN"
-      },
-      "outputs": [],
-      "source": [
-        "c = data['d'].value_counts()\n",
-        "c"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "8LvmGe8LwauN"
-      },
-      "outputs": [],
-      "source": [
-        "def cw(df):\n",
-        "    c0, c1 = np.bincount(df['d'])\n",
-        "    w0 = (1 / c0) * (len(df)) / 2\n",
-        "    w1 = (1 / c1) * (len(df)) / 2\n",
-        "    return {0: w0, 1: w1}"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "tg3Vqz9HwauN"
-      },
-      "outputs": [],
-      "source": [
-        "class_weight = cw(data)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "ZgEWHHyHwauO"
-      },
-      "outputs": [],
-      "source": [
-        "class_weight"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "oopagEBlwauO"
-      },
-      "outputs": [],
-      "source": [
-        "class_weight[0] * c[0]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "duMTaJPMwauO"
-      },
-      "outputs": [],
-      "source": [
-        "class_weight[1] * c[1]"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Hx52BKHFwauO"
-      },
-      "outputs": [],
-      "source": [
-        "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '5'"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "CPMoJ_HxwauP"
-      },
-      "outputs": [],
-      "source": [
-        "import random\n",
-        "import tensorflow as tf\n",
-        "#from tensorflow import keras\n",
-        "import keras\n",
-        "from keras.layers import Dense\n",
-        "from keras.models import Sequential\n",
-        "from sklearn.metrics import accuracy_score\n",
-        "tf.config.run_functions_eagerly(True) # Enable eager execution"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "ireZoR5-wauP"
-      },
-      "outputs": [],
-      "source": [
-        "def set_seeds(seed=100):\n",
-        "    random.seed(seed)\n",
-        "    np.random.seed(seed)\n",
-        "    tf.random.set_seed(seed)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Utij_bOswauP"
-      },
-      "outputs": [],
-      "source": [
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "cw1QXH0XwauP"
-      },
-      "outputs": [],
-      "source": [
-        "def create_model(hl=1, hu=128, optimizer=optimizer):\n",
-        "    model = Sequential()\n",
-        "    model.add(Dense(hu, input_dim=len(cols),\n",
-        "                    activation='relu'))\n",
-        "    for _ in range(hl):\n",
-        "        model.add(Dense(hu, activation='relu'))\n",
-        "    model.add(Dense(1, activation='sigmoid'))\n",
-        "    model.compile(loss='binary_crossentropy',\n",
-        "                  optimizer=optimizer,\n",
-        "                  metrics=['accuracy'])\n",
-        "    return model"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "jDLcKnGkwauP"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "model = create_model(hl=1, hu=128)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "zq17kr9PwauQ"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "model.fit(data[cols], data['d'], epochs=50,\n",
-        "          verbose=False, class_weight=cw(data))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "hmZN7SFvwauQ"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(data[cols], data['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "dCgyVGxCwauQ"
-      },
-      "outputs": [],
-      "source": [
-        "data['p'] = np.where(model.predict(data[cols]) > 0.5, 1, 0)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "tQCDlt4zwauQ"
-      },
-      "outputs": [],
-      "source": [
-        "data['p'].value_counts()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "4V3AUaS9wauQ"
-      },
-      "outputs": [],
-      "source": [
-        "split = int(len(data) * 0.8)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "UYA_2nviwauQ"
-      },
-      "outputs": [],
-      "source": [
-        "train = data.iloc[:split].copy()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "lxVg2FNfwauR"
-      },
-      "outputs": [],
-      "source": [
-        "train['d']"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "H5S-PPWSwauR"
-      },
-      "outputs": [],
-      "source": [
-        "test = data.iloc[split:].copy()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "PLxSSzZdwauR"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=1, hu=128, optimizer=optimizer)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "DH-XEz5PwauR"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(train[cols], train['d'],\n",
-        "          epochs=50, verbose=False,\n",
-        "          validation_split=0.2, shuffle=False,\n",
-        "          class_weight=cw(train))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "m9W0q_SFwauR"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(train[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "i4Acc9FXwauR"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(test[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "OWopTNVgwauS"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'] = np.where(model.predict(test[cols]) > 0.5, 1, 0)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "_SHp65JEwauS"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'].value_counts()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "eOsLEiVqwauS"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "iSufdCjKwauS"
-      },
-      "outputs": [],
-      "source": [
-        "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "ygJXG2rXwauS"
-      },
-      "source": [
-        "## Normalization"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "6X_d5FhfwauT"
-      },
-      "outputs": [],
-      "source": [
-        "mu, std = train.mean(), train.std()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "fU0Pr_KUwauT"
-      },
-      "outputs": [],
-      "source": [
-        "train_ = (train - mu) / std"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "NKPUI36QwauT"
-      },
-      "outputs": [],
-      "source": [
-        "# train_.std().round(3)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "NSs_CMgFwauT"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=1, hu=128, optimizer=optimizer)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "szMd15XFwauU"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(train_[cols], train['d'],\n",
-        "          epochs=50, verbose=False,\n",
-        "          validation_split=0.2, shuffle=False,\n",
-        "          class_weight=cw(train))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "mp_lp6tiwauU"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "g1B3hK8IwauU"
-      },
-      "outputs": [],
-      "source": [
-        "test_ = (test - mu) / std"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "FlwqARvNwauU"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(test_[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "To8jc1ngwauU"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, 0)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "zif7mmGywauV"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'].value_counts()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "xm3gJKwiwauV"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "HbxZRDrTwauV"
-      },
-      "outputs": [],
-      "source": [
-        "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "4B46XwT2wauV"
-      },
-      "source": [
-        "## Dropout"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "majdsHIAwauV"
-      },
-      "outputs": [],
-      "source": [
-        "from keras.layers import Dropout"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "BB5mDjh4wauV"
-      },
-      "outputs": [],
-      "source": [
-        "def create_model(hl=1, hu=128, dropout=True, rate=0.3,\n",
-        "                 optimizer=optimizer):\n",
-        "    model = Sequential()\n",
-        "    model.add(Dense(hu, input_dim=len(cols),\n",
-        "                    activation='relu'))\n",
-        "    if dropout:\n",
-        "        model.add(Dropout(rate, seed=100))\n",
-        "    for _ in range(hl):\n",
-        "        model.add(Dense(hu, activation='relu'))\n",
-        "        if dropout:\n",
-        "            model.add(Dropout(rate, seed=100))\n",
-        "    model.add(Dense(1, activation='sigmoid'))\n",
-        "    model.compile(loss='binary_crossentropy', optimizer=optimizer,\n",
-        "                 metrics=['accuracy'])\n",
-        "    return model"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "NmX5PqHmwauW"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=1, hu=128, optimizer=optimizer)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "FX2aPK0DwauW"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(train_[cols], train['d'],\n",
-        "          epochs=50, verbose=False,\n",
-        "          validation_split=0.15, shuffle=False,\n",
-        "          class_weight=cw(train))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "XniC2QqmwauW"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "DPk8wW_cwauW"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(test_[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "ovNG216IwauZ"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "ngix2XPOwaua"
-      },
-      "outputs": [],
-      "source": [
-        "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "5l2bbBVnwaua"
-      },
-      "source": [
-        "## Regularization"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "-iVh6mFawaua"
-      },
-      "outputs": [],
-      "source": [
-        "from keras.regularizers import l1, l2"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "aRHeXv3dwaub"
-      },
-      "outputs": [],
-      "source": [
-        "def create_model(hl=1, hu=128, dropout=False, rate=0.3,\n",
-        "                 regularize=False, reg=l1(0.0005),\n",
-        "                 optimizer=optimizer, input_dim=len(cols)):\n",
-        "    if not regularize:\n",
-        "        reg = None\n",
-        "    model = Sequential()\n",
-        "    model.add(Dense(hu, input_dim=input_dim,\n",
-        "                    activity_regularizer=reg,\n",
-        "                    activation='relu'))\n",
-        "    if dropout:\n",
-        "        model.add(Dropout(rate, seed=100))\n",
-        "    for _ in range(hl):\n",
-        "        model.add(Dense(hu, activation='relu',\n",
-        "                        activity_regularizer=reg))\n",
-        "        if dropout:\n",
-        "            model.add(Dropout(rate, seed=100))\n",
-        "    model.add(Dense(1, activation='sigmoid'))\n",
-        "    model.compile(loss='binary_crossentropy', optimizer=optimizer,\n",
-        "                 metrics=['accuracy'])\n",
-        "    return model"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "q3aUpsgMwaub"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=1, hu=128, regularize=True, optimizer=optimizer)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "fk9LWF7zwaub"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(train_[cols], train['d'],\n",
-        "          epochs=50, verbose=False,\n",
-        "          validation_split=0.2, shuffle=False,\n",
-        "          class_weight=cw(train))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "t3qOH4rBwaub"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "23JZBgXtwaub"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(test_[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "NPWsYmlewauc"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Q-vm1_Zpwauc"
-      },
-      "outputs": [],
-      "source": [
-        "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "-dChn0eLwauc"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=2, hu=128,\n",
-        "                     dropout=True, rate=0.3,\n",
-        "                     regularize=True, reg=l2(0.001),\n",
-        "                     optimizer=optimizer\n",
-        "                    )"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "CtHwkqwRwauc"
-      },
-      "outputs": [],
-      "source": [
-        "%%time\n",
-        "hist = model.fit(train_[cols], train['d'],\n",
-        "          epochs=50, verbose=False,\n",
-        "          validation_split=0.2, shuffle=False,\n",
-        "          class_weight=cw(train))"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "9hXMEdGYwauc"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "tF5U9oppwaud"
-      },
-      "outputs": [],
-      "source": [
-        "model.evaluate(test_[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "x053_YAWwaud"
-      },
-      "outputs": [],
-      "source": [
-        "res = pd.DataFrame(hist.history)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Lj2WXRBqwaud"
-      },
-      "outputs": [],
-      "source": [
-        "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "wr39kmCHwaud"
-      },
-      "outputs": [],
-      "source": [
-        "res.mean()['accuracy'] - res.mean()['val_accuracy']"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "du1__EJEwaue"
-      },
-      "source": [
-        "## Bagging"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "So29tRPzwaue"
-      },
-      "outputs": [],
-      "source": [
-        "from sklearn.ensemble import BaggingClassifier\n",
-        "#from keras.wrappers.scikit_learn import KerasClassifier\n",
-        "from scikeras.wrappers import KerasClassifier"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "3IHWwz29waue"
-      },
-      "outputs": [],
-      "source": [
-        "len(cols)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "7WMnJwQkwaue"
-      },
-      "outputs": [],
-      "source": [
-        "max_features = 0.75"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "xhi_fKigwaue"
-      },
-      "outputs": [],
-      "source": [
-        "set_seeds()\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model = create_model(hl=2, hu=128,\n",
-        "                     dropout=True, rate=0.3,\n",
-        "                     regularize=True, reg=l2(0.001),\n",
-        "                     optimizer=optimizer\n",
-        "                    )\n",
-        "base_estimator = KerasClassifier(model=create_model,\n",
-        "                        verbose=False, epochs=20, hl=1, hu=128,\n",
-        "                        dropout=True, regularize=False,\n",
-        "                        input_dim=int(len(cols) * max_features),\n",
-        "                        optimizer=optimizer)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 97,
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/",
-          "height": 216
-        },
-        "id": "acG-_fzzwauf",
-        "outputId": "1b4ee570-4c69-4544-fbc0-b4e456a85122"
-      },
-      "outputs": [
-        {
-          "output_type": "error",
-          "ename": "TypeError",
-          "evalue": "BaggingClassifier.__init__() got an unexpected keyword argument 'optimizer'",
-          "traceback": [
-            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-            "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
-            "\u001b[0;32m/tmp/ipython-input-974366293.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0moptimizer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mkeras\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moptimizers\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mAdam\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlearning_rate\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.001\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m model_bag = BaggingClassifier(estimator=base_estimator,\n\u001b[0m\u001b[1;32m      3\u001b[0m                           \u001b[0mn_estimators\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m15\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m                           \u001b[0mmax_samples\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.75\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m                           \u001b[0mmax_features\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmax_features\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
-            "\u001b[0;31mTypeError\u001b[0m: BaggingClassifier.__init__() got an unexpected keyword argument 'optimizer'"
-          ]
-        }
-      ],
-      "source": [
-        "\n",
-        "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
-        "model_bag = BaggingClassifier(estimator=base_estimator,\n",
-        "                          n_estimators=15,\n",
-        "                          max_samples=0.75,\n",
-        "                          max_features=max_features,\n",
-        "                          bootstrap=True,\n",
-        "                          bootstrap_features=True,\n",
-        "                          n_jobs=1,\n",
-        "                          random_state=100\n",
-        "                         )"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "V6IaGhBCwauf"
-      },
-      "outputs": [],
-      "source": [
-        "%time model_bag.fit(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Dvqs-VBMwauf"
-      },
-      "outputs": [],
-      "source": [
-        "model_bag.score(train_[cols], train['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "uTvYjD7mwauf"
-      },
-      "outputs": [],
-      "source": [
-        "model_bag.score(test_[cols], test['d'])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "YtK33hcMwaug"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'] = model_bag.predict(test_[cols])"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "Wi8WtM3_waug"
-      },
-      "outputs": [],
-      "source": [
-        "test['p'].value_counts()"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "Bxx_y0ORwauh"
-      },
-      "source": [
-        "## Optimizers"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "pmrHA1j6wauh"
-      },
-      "outputs": [],
-      "source": [
-        "import time"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": null,
-      "metadata": {
-        "id": "1fbPzHnGwauh"
-      },
-      "outputs": [],
-      "source": [
-        "optimizers = ['sgd', 'rmsprop', 'adagrad', 'adadelta',\n",
-        "              'adam', 'adamax', 'nadam']"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 93,
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "X9LzZPHpwaui",
-        "outputId": "a5d992a2-06f0-4056-bb4b-f8c182ca5a8f"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stderr",
-          "text": [
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n",
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n",
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n",
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n"
-          ]
-        },
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "nadam      | time[s]: 223.8490 | in-sample=0.7446 | out-of-sample=0.6316\n",
-            "CPU times: user 16min 8s, sys: 3.01 s, total: 16min 11s\n",
-            "Wall time: 16min 56s\n"
-          ]
-        }
-      ],
-      "source": [
-        "%%time\n",
-        "for optimizer in optimizers:\n",
-        "    set_seeds()\n",
-        "    model = create_model(hl=1, hu=128,\n",
-        "                     dropout=True, rate=0.3,\n",
-        "                     regularize=False, reg=l2(0.001),\n",
-        "                     optimizer=optimizer\n",
-        "                    )\n",
-        "    t0 = time.time()\n",
-        "    model.fit(train_[cols], train['d'],\n",
-        "              epochs=50, verbose=False,\n",
-        "              validation_split=0.2, shuffle=False,\n",
-        "              class_weight=cw(train))\n",
-        "    t1 = time.time()\n",
-        "    t = t1 - t0\n",
-        "    acc_tr = model.evaluate(train_[cols], train['d'], verbose=False)[1]\n",
-        "    acc_te = model.evaluate(test_[cols], test['d'], verbose=False)[1]\n",
-        "    out = f'{optimizer:10s} | time[s]: {t:.4f} | in-sample={acc_tr:.4f}'\n",
-        "    out += f' | out-of-sample={acc_te:.4f}'\n",
-        "    print(out)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 94,
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "-NlWo8Kkwaui",
-        "outputId": "1b2b1bf2-3e68-436a-b94a-ec48e45c9731"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "\u001b[1m14/14\u001b[0m \u001b[32m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 7ms/step\n"
-          ]
-        },
-        {
-          "output_type": "stream",
-          "name": "stderr",
-          "text": [
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n",
-            "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
-            "  warnings.warn(\n"
-          ]
-        }
-      ],
-      "source": [
-        "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, 0)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 95,
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/",
-          "height": 178
-        },
-        "id": "xZCtk8gewaui",
-        "outputId": "ee76702e-2dde-46e7-e68c-8891c24eb155"
-      },
-      "outputs": [
-        {
-          "output_type": "execute_result",
-          "data": {
-            "text/plain": [
-              "p\n",
-              "1    226\n",
-              "0    211\n",
-              "Name: count, dtype: int64"
-            ],
-            "text/html": [
-              "<div>\n",
-              "<style scoped>\n",
-              "    .dataframe tbody tr th:only-of-type {\n",
-              "        vertical-align: middle;\n",
-              "    }\n",
-              "\n",
-              "    .dataframe tbody tr th {\n",
-              "        vertical-align: top;\n",
-              "    }\n",
-              "\n",
-              "    .dataframe thead th {\n",
-              "        text-align: right;\n",
-              "    }\n",
-              "</style>\n",
-              "<table border=\"1\" class=\"dataframe\">\n",
-              "  <thead>\n",
-              "    <tr style=\"text-align: right;\">\n",
-              "      <th></th>\n",
-              "      <th>count</th>\n",
-              "    </tr>\n",
-              "    <tr>\n",
-              "      <th>p</th>\n",
-              "      <th></th>\n",
-              "    </tr>\n",
-              "  </thead>\n",
-              "  <tbody>\n",
-              "    <tr>\n",
-              "      <th>1</th>\n",
-              "      <td>226</td>\n",
-              "    </tr>\n",
-              "    <tr>\n",
-              "      <th>0</th>\n",
-              "      <td>211</td>\n",
-              "    </tr>\n",
-              "  </tbody>\n",
-              "</table>\n",
-              "</div><br><label><b>dtype:</b> int64</label>"
-            ]
-          },
-          "metadata": {},
-          "execution_count": 95
-        }
-      ],
-      "source": [
-        "test['p'].value_counts()"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 96,
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "ybkl9O1Ywaui",
-        "outputId": "d86f827f-80e7-4c90-a691-565acc15e98c"
-      },
-      "outputs": [
-        {
-          "output_type": "execute_result",
-          "data": {
-            "text/plain": [
-              "0.631578947368421"
-            ]
-          },
-          "metadata": {},
-          "execution_count": 96
-        }
+ "cells": [
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "ZSGtiUGQwat-"
+   },
+   "source": [
+    "<img src=\"https://certificate.tpq.io/taim_logo.png\" width=\"350px\" align=\"right\">"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "GnFAhJjdwauA"
+   },
+   "source": [
+    "# Artificial Intelligence in Finance"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "HHRFGXFFwauB"
+   },
+   "source": [
+    "## Dense Neural Networks"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "vmIykJO_wauC"
+   },
+   "source": [
+    "Dr Yves J Hilpisch | The AI Machine\n",
+    "\n",
+    "http://aimachine.io | http://twitter.com/dyjh"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "DIX7mDDfwauD"
+   },
+   "outputs": [],
+   "source": [
+    "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
+    "import sys\n",
+    "sys.path.append('ai_in_finance_book')\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Bh2-JIy6wauF"
+   },
+   "outputs": [],
+   "source": [
+    "import os\n",
+    "import numpy as np\n",
+    "import pandas as pd\n",
+    "from pylab import plt, mpl\n",
+    "plt.style.use('seaborn-v0_8')\n",
+    "mpl.rcParams['savefig.dpi'] = 300\n",
+    "mpl.rcParams['font.family'] = 'serif'\n",
+    "pd.set_option('display.precision', 4)\n",
+    "np.set_printoptions(suppress=True, precision=4)\n",
+    "os.environ['PYTHONHASHSEED'] = '0'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "TFuNPCAyU5-9"
+   },
+   "outputs": [],
+   "source": [
+    "!pip install scikeras"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "cj4aX2uWwauF"
+   },
+   "source": [
+    "## The Data"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "O4JqsE3uwauI"
+   },
+   "outputs": [],
+   "source": [
+    "url = 'http://hilpisch.com/aiif_eikon_id_eur_usd.csv'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Mlq_qkguwauJ"
+   },
+   "outputs": [],
+   "source": [
+    "symbol = 'EUR_USD'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "KXSofZY0wauK"
+   },
+   "outputs": [],
+   "source": [
+    "raw = pd.read_csv(url, index_col=0, parse_dates=True)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "vqbKPIZgwauK"
+   },
+   "outputs": [],
+   "source": [
+    "raw.head()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "8vy9cj0UwauL"
+   },
+   "outputs": [],
+   "source": [
+    "raw.info()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "JbOxVpNpwauL"
+   },
+   "outputs": [],
+   "source": [
+    "data = pd.DataFrame(raw['CLOSE'].loc[:])\n",
+    "data.columns = [symbol]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "cMsWk-P1wauL"
+   },
+   "outputs": [],
+   "source": [
+    "data = data.resample('1h', label='right').last().ffill()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "XpuuFJuzwauM"
+   },
+   "outputs": [],
+   "source": [
+    "data.info()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "u7zB4kZ_wauM"
+   },
+   "outputs": [],
+   "source": [
+    "data.plot(figsize=(10, 6));"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "-x2nsck2wauM"
+   },
+   "source": [
+    "## Baseline Prediction"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "7MGAhH3xwauM"
+   },
+   "outputs": [],
+   "source": [
+    "lags = 5"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "JkaOKhWJwauM"
+   },
+   "outputs": [],
+   "source": [
+    "def add_lags(data, symbol, lags, window=20):\n",
+    "    cols = []\n",
+    "    df = data.copy()\n",
+    "    df.dropna(inplace=True)\n",
+    "    df['r'] = np.log(df / df.shift())\n",
+    "    df['sma'] = df[symbol].rolling(window).mean()\n",
+    "    df['min'] = df[symbol].rolling(window).min()\n",
+    "    df['max'] = df[symbol].rolling(window).max()\n",
+    "    df['mom'] = df['r'].rolling(window).mean()\n",
+    "    df['vol'] = df['r'].rolling(window).std()\n",
+    "    df.dropna(inplace=True)\n",
+    "    df['d'] = np.where(df['r'] > 0, 1, 0)\n",
+    "    features = [symbol, 'r', 'd', 'sma', 'min', 'max', 'mom', 'vol']\n",
+    "    for f in features:\n",
+    "        for lag in range(1, lags + 1):\n",
+    "            col = f'{f}_lag_{lag}'\n",
+    "            df[col] = df[f].shift(lag)\n",
+    "            cols.append(col)\n",
+    "    df.dropna(inplace=True)\n",
+    "    return df, cols"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "LDCaFzJ2wauN"
+   },
+   "outputs": [],
+   "source": [
+    "data, cols = add_lags(data, symbol, lags)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "GOkyHK4ywauN"
+   },
+   "outputs": [],
+   "source": [
+    "len(data)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "_Yqtqo59wauN"
+   },
+   "outputs": [],
+   "source": [
+    "# data.iloc[:10, :14].round(4)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "wEcYt9PJwauN"
+   },
+   "outputs": [],
+   "source": [
+    "c = data['d'].value_counts()\n",
+    "c"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "8LvmGe8LwauN"
+   },
+   "outputs": [],
+   "source": [
+    "def cw(df):\n",
+    "    c0, c1 = np.bincount(df['d'])\n",
+    "    w0 = (1 / c0) * (len(df)) / 2\n",
+    "    w1 = (1 / c1) * (len(df)) / 2\n",
+    "    return {0: w0, 1: w1}"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "tg3Vqz9HwauN"
+   },
+   "outputs": [],
+   "source": [
+    "class_weight = cw(data)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "ZgEWHHyHwauO"
+   },
+   "outputs": [],
+   "source": [
+    "class_weight"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "oopagEBlwauO"
+   },
+   "outputs": [],
+   "source": [
+    "class_weight[0] * c[0]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "duMTaJPMwauO"
+   },
+   "outputs": [],
+   "source": [
+    "class_weight[1] * c[1]"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Hx52BKHFwauO"
+   },
+   "outputs": [],
+   "source": [
+    "os.environ['TF_CPP_MIN_LOG_LEVEL'] = '5'"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "CPMoJ_HxwauP"
+   },
+   "outputs": [],
+   "source": [
+    "import random\n",
+    "import tensorflow as tf\n",
+    "#from tensorflow import keras\n",
+    "import keras\n",
+    "from keras.layers import Dense\n",
+    "from keras.models import Sequential\n",
+    "from sklearn.metrics import accuracy_score\n",
+    "tf.config.run_functions_eagerly(True) # Enable eager execution"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "ireZoR5-wauP"
+   },
+   "outputs": [],
+   "source": [
+    "def set_seeds(seed=100):\n",
+    "    random.seed(seed)\n",
+    "    np.random.seed(seed)\n",
+    "    tf.random.set_seed(seed)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Utij_bOswauP"
+   },
+   "outputs": [],
+   "source": [
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "cw1QXH0XwauP"
+   },
+   "outputs": [],
+   "source": [
+    "def create_model(hl=1, hu=128, optimizer=optimizer):\n",
+    "    model = Sequential()\n",
+    "    model.add(Dense(hu, input_dim=len(cols),\n",
+    "                    activation='relu'))\n",
+    "    for _ in range(hl):\n",
+    "        model.add(Dense(hu, activation='relu'))\n",
+    "    model.add(Dense(1, activation='sigmoid'))\n",
+    "    model.compile(loss='binary_crossentropy',\n",
+    "                  optimizer=optimizer,\n",
+    "                  metrics=['accuracy'])\n",
+    "    return model"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "jDLcKnGkwauP"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "model = create_model(hl=1, hu=128)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "zq17kr9PwauQ"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "model.fit(data[cols], data['d'], epochs=50,\n",
+    "          verbose=False, class_weight=cw(data))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "hmZN7SFvwauQ"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(data[cols], data['d'])"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "bf4fff3e",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "dCgyVGxCwauQ"
+   },
+   "source": [
+    "data['p'] = np.where(model.predict(data[cols]) > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "0c1f3fc9",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "data['p'] = np.where(model(tf.convert_to_tensor(data[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "tQCDlt4zwauQ"
+   },
+   "outputs": [],
+   "source": [
+    "data['p'].value_counts()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "4V3AUaS9wauQ"
+   },
+   "outputs": [],
+   "source": [
+    "split = int(len(data) * 0.8)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "UYA_2nviwauQ"
+   },
+   "outputs": [],
+   "source": [
+    "train = data.iloc[:split].copy()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "lxVg2FNfwauR"
+   },
+   "outputs": [],
+   "source": [
+    "train['d']"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "H5S-PPWSwauR"
+   },
+   "outputs": [],
+   "source": [
+    "test = data.iloc[split:].copy()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "PLxSSzZdwauR"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=1, hu=128, optimizer=optimizer)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "DH-XEz5PwauR"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(train[cols], train['d'],\n",
+    "          epochs=50, verbose=False,\n",
+    "          validation_split=0.2, shuffle=False,\n",
+    "          class_weight=cw(train))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "m9W0q_SFwauR"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(train[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "i4Acc9FXwauR"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(test[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "09734408",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "OWopTNVgwauS"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(test[cols]) > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "fce1f547",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(test[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "_SHp65JEwauS"
+   },
+   "outputs": [],
+   "source": [
+    "test['p'].value_counts()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "eOsLEiVqwauS"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "iSufdCjKwauS"
+   },
+   "outputs": [],
+   "source": [
+    "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "ygJXG2rXwauS"
+   },
+   "source": [
+    "## Normalization"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "6X_d5FhfwauT"
+   },
+   "outputs": [],
+   "source": [
+    "mu, std = train.mean(), train.std()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "fU0Pr_KUwauT"
+   },
+   "outputs": [],
+   "source": [
+    "train_ = (train - mu) / std"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "NKPUI36QwauT"
+   },
+   "outputs": [],
+   "source": [
+    "# train_.std().round(3)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "NSs_CMgFwauT"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=1, hu=128, optimizer=optimizer)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "szMd15XFwauU"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(train_[cols], train['d'],\n",
+    "          epochs=50, verbose=False,\n",
+    "          validation_split=0.2, shuffle=False,\n",
+    "          class_weight=cw(train))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "mp_lp6tiwauU"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "g1B3hK8IwauU"
+   },
+   "outputs": [],
+   "source": [
+    "test_ = (test - mu) / std"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "FlwqARvNwauU"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(test_[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "eee07a43",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "To8jc1ngwauU"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "1593f466",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(test_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "zif7mmGywauV"
+   },
+   "outputs": [],
+   "source": [
+    "test['p'].value_counts()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "xm3gJKwiwauV"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "HbxZRDrTwauV"
+   },
+   "outputs": [],
+   "source": [
+    "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "4B46XwT2wauV"
+   },
+   "source": [
+    "## Dropout"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "majdsHIAwauV"
+   },
+   "outputs": [],
+   "source": [
+    "from keras.layers import Dropout"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "BB5mDjh4wauV"
+   },
+   "outputs": [],
+   "source": [
+    "def create_model(hl=1, hu=128, dropout=True, rate=0.3,\n",
+    "                 optimizer=optimizer):\n",
+    "    model = Sequential()\n",
+    "    model.add(Dense(hu, input_dim=len(cols),\n",
+    "                    activation='relu'))\n",
+    "    if dropout:\n",
+    "        model.add(Dropout(rate, seed=100))\n",
+    "    for _ in range(hl):\n",
+    "        model.add(Dense(hu, activation='relu'))\n",
+    "        if dropout:\n",
+    "            model.add(Dropout(rate, seed=100))\n",
+    "    model.add(Dense(1, activation='sigmoid'))\n",
+    "    model.compile(loss='binary_crossentropy', optimizer=optimizer,\n",
+    "                 metrics=['accuracy'])\n",
+    "    return model"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "NmX5PqHmwauW"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=1, hu=128, optimizer=optimizer)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "FX2aPK0DwauW"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(train_[cols], train['d'],\n",
+    "          epochs=50, verbose=False,\n",
+    "          validation_split=0.15, shuffle=False,\n",
+    "          class_weight=cw(train))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "XniC2QqmwauW"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "DPk8wW_cwauW"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(test_[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "ovNG216IwauZ"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "ngix2XPOwaua"
+   },
+   "outputs": [],
+   "source": [
+    "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "5l2bbBVnwaua"
+   },
+   "source": [
+    "## Regularization"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "-iVh6mFawaua"
+   },
+   "outputs": [],
+   "source": [
+    "from keras.regularizers import l1, l2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "aRHeXv3dwaub"
+   },
+   "outputs": [],
+   "source": [
+    "def create_model(hl=1, hu=128, dropout=False, rate=0.3,\n",
+    "                 regularize=False, reg=l1(0.0005),\n",
+    "                 optimizer=optimizer, input_dim=len(cols)):\n",
+    "    if not regularize:\n",
+    "        reg = None\n",
+    "    model = Sequential()\n",
+    "    model.add(Dense(hu, input_dim=input_dim,\n",
+    "                    activity_regularizer=reg,\n",
+    "                    activation='relu'))\n",
+    "    if dropout:\n",
+    "        model.add(Dropout(rate, seed=100))\n",
+    "    for _ in range(hl):\n",
+    "        model.add(Dense(hu, activation='relu',\n",
+    "                        activity_regularizer=reg))\n",
+    "        if dropout:\n",
+    "            model.add(Dropout(rate, seed=100))\n",
+    "    model.add(Dense(1, activation='sigmoid'))\n",
+    "    model.compile(loss='binary_crossentropy', optimizer=optimizer,\n",
+    "                 metrics=['accuracy'])\n",
+    "    return model"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "q3aUpsgMwaub"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=1, hu=128, regularize=True, optimizer=optimizer)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "fk9LWF7zwaub"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(train_[cols], train['d'],\n",
+    "          epochs=50, verbose=False,\n",
+    "          validation_split=0.2, shuffle=False,\n",
+    "          class_weight=cw(train))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "t3qOH4rBwaub"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "23JZBgXtwaub"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(test_[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "NPWsYmlewauc"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Q-vm1_Zpwauc"
+   },
+   "outputs": [],
+   "source": [
+    "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "-dChn0eLwauc"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=2, hu=128,\n",
+    "                     dropout=True, rate=0.3,\n",
+    "                     regularize=True, reg=l2(0.001),\n",
+    "                     optimizer=optimizer\n",
+    "                    )"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "CtHwkqwRwauc"
+   },
+   "outputs": [],
+   "source": [
+    "%%time\n",
+    "hist = model.fit(train_[cols], train['d'],\n",
+    "          epochs=50, verbose=False,\n",
+    "          validation_split=0.2, shuffle=False,\n",
+    "          class_weight=cw(train))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "9hXMEdGYwauc"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "tF5U9oppwaud"
+   },
+   "outputs": [],
+   "source": [
+    "model.evaluate(test_[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "x053_YAWwaud"
+   },
+   "outputs": [],
+   "source": [
+    "res = pd.DataFrame(hist.history)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Lj2WXRBqwaud"
+   },
+   "outputs": [],
+   "source": [
+    "res[['accuracy', 'val_accuracy']].plot(figsize=(10, 6), style='--');"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "wr39kmCHwaud"
+   },
+   "outputs": [],
+   "source": [
+    "res.mean()['accuracy'] - res.mean()['val_accuracy']"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "du1__EJEwaue"
+   },
+   "source": [
+    "## Bagging"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "So29tRPzwaue"
+   },
+   "outputs": [],
+   "source": [
+    "from sklearn.ensemble import BaggingClassifier\n",
+    "#from keras.wrappers.scikit_learn import KerasClassifier\n",
+    "from scikeras.wrappers import KerasClassifier"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "3IHWwz29waue"
+   },
+   "outputs": [],
+   "source": [
+    "len(cols)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "7WMnJwQkwaue"
+   },
+   "outputs": [],
+   "source": [
+    "max_features = 0.75"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "xhi_fKigwaue"
+   },
+   "outputs": [],
+   "source": [
+    "set_seeds()\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model = create_model(hl=2, hu=128,\n",
+    "                     dropout=True, rate=0.3,\n",
+    "                     regularize=True, reg=l2(0.001),\n",
+    "                     optimizer=optimizer\n",
+    "                    )\n",
+    "base_estimator = KerasClassifier(model=create_model,\n",
+    "                        verbose=False, epochs=20, hl=1, hu=128,\n",
+    "                        dropout=True, regularize=False,\n",
+    "                        input_dim=int(len(cols) * max_features),\n",
+    "                        optimizer=optimizer)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 97,
+   "metadata": {
+    "colab": {
+     "base_uri": "https://localhost:8080/",
+     "height": 216
+    },
+    "id": "acG-_fzzwauf",
+    "outputId": "1b4ee570-4c69-4544-fbc0-b4e456a85122"
+   },
+   "outputs": [
+    {
+     "ename": "TypeError",
+     "evalue": "BaggingClassifier.__init__() got an unexpected keyword argument 'optimizer'",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
+      "\u001b[0;32m/tmp/ipython-input-974366293.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0moptimizer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mkeras\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moptimizers\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mAdam\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlearning_rate\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.001\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 2\u001b[0;31m model_bag = BaggingClassifier(estimator=base_estimator,\n\u001b[0m\u001b[1;32m      3\u001b[0m                           \u001b[0mn_estimators\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m15\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m                           \u001b[0mmax_samples\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0.75\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m                           \u001b[0mmax_features\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmax_features\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
+      "\u001b[0;31mTypeError\u001b[0m: BaggingClassifier.__init__() got an unexpected keyword argument 'optimizer'"
+     ]
+    }
+   ],
+   "source": [
+    "\n",
+    "optimizer = keras.optimizers.Adam(learning_rate=0.001)\n",
+    "model_bag = BaggingClassifier(estimator=base_estimator,\n",
+    "                          n_estimators=15,\n",
+    "                          max_samples=0.75,\n",
+    "                          max_features=max_features,\n",
+    "                          bootstrap=True,\n",
+    "                          bootstrap_features=True,\n",
+    "                          n_jobs=1,\n",
+    "                          random_state=100\n",
+    "                         )"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "V6IaGhBCwauf"
+   },
+   "outputs": [],
+   "source": [
+    "%time model_bag.fit(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Dvqs-VBMwauf"
+   },
+   "outputs": [],
+   "source": [
+    "model_bag.score(train_[cols], train['d'])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "uTvYjD7mwauf"
+   },
+   "outputs": [],
+   "source": [
+    "model_bag.score(test_[cols], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "a2bf5dd8",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "id": "YtK33hcMwaug"
+   },
+   "source": [
+    "test['p'] = model_bag.predict(test_[cols])"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "94dd8f73",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "test['p'] = model_bag(tf.convert_to_tensor(test_[cols], dtype=tf.float32), training=False).numpy()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "Wi8WtM3_waug"
+   },
+   "outputs": [],
+   "source": [
+    "test['p'].value_counts()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "Bxx_y0ORwauh"
+   },
+   "source": [
+    "## Optimizers"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "pmrHA1j6wauh"
+   },
+   "outputs": [],
+   "source": [
+    "import time"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {
+    "id": "1fbPzHnGwauh"
+   },
+   "outputs": [],
+   "source": [
+    "optimizers = ['sgd', 'rmsprop', 'adagrad', 'adadelta',\n",
+    "              'adam', 'adamax', 'nadam']"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 93,
+   "metadata": {
+    "colab": {
+     "base_uri": "https://localhost:8080/"
+    },
+    "id": "X9LzZPHpwaui",
+    "outputId": "a5d992a2-06f0-4056-bb4b-f8c182ca5a8f"
+   },
+   "outputs": [
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
+      "  warnings.warn(\n",
+      "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
+      "  warnings.warn(\n",
+      "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
+      "  warnings.warn(\n",
+      "/usr/local/lib/python3.12/dist-packages/tensorflow/python/data/ops/structured_function.py:258: UserWarning: Even though the `tf.config.experimental_run_functions_eagerly` option is set, this option does not apply to tf.data functions. To force eager execution of tf.data functions, please use `tf.data.experimental.enable_debug_mode()`.\n",
+      "  warnings.warn(\n"
+     ]
+    },
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "nadam      | time[s]: 223.8490 | in-sample=0.7446 | out-of-sample=0.6316\n",
+      "CPU times: user 16min 8s, sys: 3.01 s, total: 16min 11s\n",
+      "Wall time: 16min 56s\n"
+     ]
+    }
+   ],
+   "source": [
+    "%%time\n",
+    "for optimizer in optimizers:\n",
+    "    set_seeds()\n",
+    "    model = create_model(hl=1, hu=128,\n",
+    "                     dropout=True, rate=0.3,\n",
+    "                     regularize=False, reg=l2(0.001),\n",
+    "                     optimizer=optimizer\n",
+    "                    )\n",
+    "    t0 = time.time()\n",
+    "    model.fit(train_[cols], train['d'],\n",
+    "              epochs=50, verbose=False,\n",
+    "              validation_split=0.2, shuffle=False,\n",
+    "              class_weight=cw(train))\n",
+    "    t1 = time.time()\n",
+    "    t = t1 - t0\n",
+    "    acc_tr = model.evaluate(train_[cols], train['d'], verbose=False)[1]\n",
+    "    acc_te = model.evaluate(test_[cols], test['d'], verbose=False)[1]\n",
+    "    out = f'{optimizer:10s} | time[s]: {t:.4f} | in-sample={acc_tr:.4f}'\n",
+    "    out += f' | out-of-sample={acc_te:.4f}'\n",
+    "    print(out)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "ad16b16f",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup",
+    "colab": {
+     "base_uri": "https://localhost:8080/"
+    },
+    "id": "-NlWo8Kkwaui",
+    "outputId": "1b2b1bf2-3e68-436a-b94a-ec48e45c9731"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "2e7d5c0d",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(test_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 95,
+   "metadata": {
+    "colab": {
+     "base_uri": "https://localhost:8080/",
+     "height": 178
+    },
+    "id": "xZCtk8gewaui",
+    "outputId": "ee76702e-2dde-46e7-e68c-8891c24eb155"
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<div>\n",
+       "<style scoped>\n",
+       "    .dataframe tbody tr th:only-of-type {\n",
+       "        vertical-align: middle;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe tbody tr th {\n",
+       "        vertical-align: top;\n",
+       "    }\n",
+       "\n",
+       "    .dataframe thead th {\n",
+       "        text-align: right;\n",
+       "    }\n",
+       "</style>\n",
+       "<table border=\"1\" class=\"dataframe\">\n",
+       "  <thead>\n",
+       "    <tr style=\"text-align: right;\">\n",
+       "      <th></th>\n",
+       "      <th>count</th>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>p</th>\n",
+       "      <th></th>\n",
+       "    </tr>\n",
+       "  </thead>\n",
+       "  <tbody>\n",
+       "    <tr>\n",
+       "      <th>1</th>\n",
+       "      <td>226</td>\n",
+       "    </tr>\n",
+       "    <tr>\n",
+       "      <th>0</th>\n",
+       "      <td>211</td>\n",
+       "    </tr>\n",
+       "  </tbody>\n",
+       "</table>\n",
+       "</div><br><label><b>dtype:</b> int64</label>"
       ],
-      "source": [
-        "accuracy_score(test['p'], test['d'])"
-      ]
+      "text/plain": [
+       "p\n",
+       "1    226\n",
+       "0    211\n",
+       "Name: count, dtype: int64"
+      ]
+     },
+     "execution_count": 95,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "test['p'].value_counts()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 96,
+   "metadata": {
+    "colab": {
+     "base_uri": "https://localhost:8080/"
     },
+    "id": "ybkl9O1Ywaui",
+    "outputId": "d86f827f-80e7-4c90-a691-565acc15e98c"
+   },
+   "outputs": [
     {
-      "cell_type": "markdown",
-      "metadata": {
-        "id": "OOn_Saitwaui"
-      },
-      "source": [
-        "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">\n",
-        "\n",
-        "<br><br><br><a href=\"http://tpq.io\" target=\"_blank\">http://tpq.io</a> | <a href=\"http://twitter.com/dyjh\" target=\"_blank\">@dyjh</a> | <a href=\"mailto:ai@tpq.io\">ai@tpq.io</a>"
+     "data": {
+      "text/plain": [
+       "0.631578947368421"
       ]
+     },
+     "execution_count": 96,
+     "metadata": {},
+     "output_type": "execute_result"
     }
-  ],
-  "metadata": {
-    "kernelspec": {
-      "name": "python3",
-      "display_name": "Python 3"
-    },
-    "language_info": {
-      "codemirror_mode": {
-        "name": "ipython",
-        "version": 3
-      },
-      "file_extension": ".py",
-      "mimetype": "text/x-python",
-      "name": "python",
-      "nbconvert_exporter": "python",
-      "pygments_lexer": "ipython3",
-      "version": "3.10.13"
-    },
-    "colab": {
-      "provenance": []
-    }
+   ],
+   "source": [
+    "accuracy_score(test['p'], test['d'])"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {
+    "id": "OOn_Saitwaui"
+   },
+   "source": [
+    "<img src='http://hilpisch.com/taim_logo.png' width=\"350px\" align=\"right\">\n",
+    "\n",
+    "<br><br><br><a href=\"http://tpq.io\" target=\"_blank\">http://tpq.io</a> | <a href=\"http://twitter.com/dyjh\" target=\"_blank\">@dyjh</a> | <a href=\"mailto:ai@tpq.io\">ai@tpq.io</a>"
+   ]
+  }
+ ],
+ "metadata": {
+  "colab": {
+   "provenance": []
+  },
+  "kernelspec": {
+   "display_name": "Python 3",
+   "name": "python3"
   },
-  "nbformat": 4,
-  "nbformat_minor": 0
-}
\ No newline at end of file
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.10.13"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 0
+}
diff --git a/08_recurrent_networks.ipynb b/08_recurrent_networks.ipynb
index 4e4b587..641bd6a 100755
--- a/08_recurrent_networks.ipynb
+++ b/08_recurrent_networks.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -842,13 +842,28 @@
     "g_ = TimeseriesGenerator(test, test, length=lags, batch_size=5)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "e4556709",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y = model.predict(g_)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "45cc24ae",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y = model.predict(g_)"
+    "import tensorflow as tf\n",
+    "y = model(tf.convert_to_tensor(g_, dtype=tf.float32), training=False).numpy()"
    ]
   },
   {
@@ -1008,13 +1023,28 @@
     "                         length=lags, batch_size=5)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "e166a9ec",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y = model.predict(g_).flatten()"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "462c7736",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y = model.predict(g_).flatten()"
+    "import tensorflow as tf\n",
+    "y = model(tf.convert_to_tensor(g_, dtype=tf.float32), training=False).numpy().flatten()"
    ]
   },
   {
@@ -1117,13 +1147,28 @@
     "                         length=lags, batch_size=5)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "9192e9fe",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y = np.where(model.predict(g_, batch_size=None) > 0.5,\n",
+    "             1, 0).flatten()"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "6fe2b35c",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y = np.where(model.predict(g_, batch_size=None) > 0.5,\n",
+    "y = np.where(model.predict(g_, batch_size=None, verbose=0) > 0.5,\n",
     "             1, 0).flatten()"
    ]
   },
@@ -1226,13 +1271,28 @@
     "          verbose=False, class_weight=cw(train_y))"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "ccc7c338",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "y = np.where(model.predict(g_, batch_size=None) > 0.5,\n",
+    "             1, 0).flatten()"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "c1b8ac3a",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "y = np.where(model.predict(g_, batch_size=None) > 0.5,\n",
+    "y = np.where(model.predict(g_, batch_size=None, verbose=0) > 0.5,\n",
     "             1, 0).flatten()"
    ]
   },
@@ -1266,8 +1326,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -1284,4 +1344,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/09_reinforcement_learning_a.ipynb b/09_reinforcement_learning_a.ipynb
index fa50b1e..3cd5a3e 100755
--- a/09_reinforcement_learning_a.ipynb
+++ b/09_reinforcement_learning_a.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -472,15 +472,27 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "d604ebaf",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "from tensorflow.python.framework.ops import disable_eager_execution\n",
     "disable_eager_execution()"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "52e17f05",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": []
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -506,10 +518,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "e912d9f0",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "class NNAgent:\n",
     "    def __init__(self):\n",
@@ -557,6 +571,60 @@
     "                state = next_state"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "b697b837",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "class NNAgent:\n",
+    "    def __init__(self):\n",
+    "        self.max = 0\n",
+    "        self.scores = list()\n",
+    "        self.memory = list()\n",
+    "        self.model = self._build_model()\n",
+    "        \n",
+    "    def _build_model(self):\n",
+    "        model = Sequential()\n",
+    "        model.add(Dense(24, input_dim=4,\n",
+    "                        activation='relu'))\n",
+    "        model.add(Dense(1, activation='sigmoid'))\n",
+    "        model.compile(loss='binary_crossentropy',\n",
+    "                      optimizer=keras.optimizers.RMSprop(learning_rate=0.001))\n",
+    "        return model\n",
+    "        \n",
+    "    def act(self, state):\n",
+    "        if random.random() <= 0.5:\n",
+    "            return env.action_space.sample()\n",
+    "        action = np.where(self.model.predict(state, batch_size=None, verbose=0)[0, 0] > 0.5, 1, 0)\n",
+    "        return action\n",
+    "                    \n",
+    "    def train_model(self, state, action):\n",
+    "        self.model.fit(state, np.array([action,], verbose=0),\n",
+    "                       epochs=1, verbose=False)\n",
+    "    \n",
+    "    def learn(self, episodes):\n",
+    "        for e in range(1, episodes + 1):\n",
+    "            state, _ = env.reset()\n",
+    "            for _ in range(201):\n",
+    "                state = np.reshape(state, [1, 4])\n",
+    "                action = self.act(state)\n",
+    "                next_state, reward, done, trunc,  info = env.step(action)\n",
+    "                if done:\n",
+    "                    score = _ + 1\n",
+    "                    self.scores.append(score)\n",
+    "                    self.max = max(score, self.max)\n",
+    "                    print('episode: {:4d}/{} | score: {:3d} | max: {:3d}'\n",
+    "                          .format(e, episodes, score, self.max), end='\\r')\n",
+    "                    break\n",
+    "                self.memory.append((state, action))\n",
+    "                self.train_model(state, action)\n",
+    "                state = next_state"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -614,13 +682,28 @@
     "l"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "c7e8ec7b",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "accuracy_score(np.where(agent.model.predict(f) > 0.5, 1, 0), l)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "33bc7507",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "accuracy_score(np.where(agent.model.predict(f) > 0.5, 1, 0), l)"
+    "import tensorflow as tf\n",
+    "accuracy_score(np.where(agent.model(tf.convert_to_tensor(f, dtype=tf.float32), training=False).numpy() > 0.5, 1, 0), l)"
    ]
   },
   {
@@ -647,10 +730,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "cae1d2e4",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "class DQLAgent:\n",
     "    def __init__(self, gamma=0.95, hu=24, opt=keras.optimizers.Adam,\n",
@@ -742,6 +827,106 @@
     "        return trewards"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "b20e77d5",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "class DQLAgent:\n",
+    "    def __init__(self, gamma=0.95, hu=24, opt=keras.optimizers.Adam,\n",
+    "           lr=0.001, finish=False):\n",
+    "        self.finish = finish\n",
+    "        self.epsilon = 1.0\n",
+    "        self.epsilon_min = 0.01\n",
+    "        self.epsilon_decay = 0.995\n",
+    "        self.gamma = gamma\n",
+    "        self.batch_size = 32\n",
+    "        self.max_treward = 0\n",
+    "        self.averages = list()\n",
+    "        self.memory = deque(maxlen=2000)\n",
+    "        self.osn = env.observation_space.shape[0]\n",
+    "        self.model = self._build_model(hu, opt, lr)\n",
+    "        \n",
+    "    def _build_model(self, hu, opt, lr):\n",
+    "        model = Sequential()\n",
+    "        model.add(Dense(hu, input_dim=self.osn,\n",
+    "                        activation='relu'))\n",
+    "        model.add(Dense(hu, activation='relu'))\n",
+    "        model.add(Dense(env.action_space.n, activation='linear'))\n",
+    "        model.compile(loss='mse', optimizer=opt(learning_rate=lr))\n",
+    "        return model\n",
+    "        \n",
+    "    def act(self, state):\n",
+    "        if random.random() <= self.epsilon:\n",
+    "            return env.action_space.sample()\n",
+    "        action = self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()[0]\n",
+    "        return np.argmax(action)\n",
+    "    \n",
+    "    def replay(self):\n",
+    "        batch = random.sample(self.memory, self.batch_size)\n",
+    "        for state, action, reward, next_state, done in batch:\n",
+    "            if not done:\n",
+    "                reward += self.gamma * np.amax(\n",
+    "                    self.model(tf.convert_to_tensor(next_state, dtype=tf.float32), training=False).numpy()[0])\n",
+    "            target = self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()\n",
+    "            target[0, action] = reward\n",
+    "            self.model.fit(state, target, epochs=1,\n",
+    "                           verbose=False)\n",
+    "        if self.epsilon > self.epsilon_min:\n",
+    "            self.epsilon *= self.epsilon_decay\n",
+    "    \n",
+    "    def learn(self, episodes):\n",
+    "        trewards = []\n",
+    "        for e in range(1, episodes + 1):\n",
+    "            state, _ = env.reset()\n",
+    "            state = np.reshape(state, [1, self.osn])\n",
+    "            for _ in range(5000):\n",
+    "                action = self.act(state)\n",
+    "                next_state, reward, done, trunc, info = env.step(action)\n",
+    "                next_state = np.reshape(next_state,\n",
+    "                                        [1, self.osn])\n",
+    "                self.memory.append([state, action, reward,\n",
+    "                                     next_state, done])\n",
+    "                state = next_state\n",
+    "                if done:\n",
+    "                    treward = _ + 1\n",
+    "                    trewards.append(treward)\n",
+    "                    av = sum(trewards[-25:]) / 25\n",
+    "                    self.averages.append(av)\n",
+    "                    self.max_treward = max(self.max_treward, treward)\n",
+    "                    templ = 'episode: {:4d}/{} | treward: {:4d} | '\n",
+    "                    templ += 'av: {:6.1f} | max: {:4d}'\n",
+    "                    print(templ.format(e, episodes, treward, av,\n",
+    "                                       self.max_treward), end='\\r')\n",
+    "                    break\n",
+    "            if av > 195 and self.finish:\n",
+    "                print()\n",
+    "                break\n",
+    "            if len(self.memory) > self.batch_size:\n",
+    "                self.replay()\n",
+    "    def test(self, episodes):\n",
+    "        trewards = []\n",
+    "        for e in range(1, episodes + 1):\n",
+    "            state, _ = env.reset()\n",
+    "            for _ in range(5001):\n",
+    "                state = np.reshape(state, [1, self.osn])\n",
+    "                action = np.argmax(self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()[0])\n",
+    "                next_state, reward, done, trunc, info = env.step(action)\n",
+    "                state = next_state\n",
+    "                if done:\n",
+    "                    treward = _ + 1\n",
+    "                    trewards.append(treward)\n",
+    "                    print('episode: {:4d}/{} | treward: {:4d}'\n",
+    "                          .format(e, episodes, treward), end='\\r')\n",
+    "                    break\n",
+    "        return trewards"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -997,8 +1182,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -1015,4 +1200,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/09_reinforcement_learning_b.ipynb b/09_reinforcement_learning_b.ipynb
index 0daa7c2..a73c756 100755
--- a/09_reinforcement_learning_b.ipynb
+++ b/09_reinforcement_learning_b.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -90,15 +90,27 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "896faae7",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "from tensorflow.python.framework.ops import disable_eager_execution\n",
     "disable_eager_execution()"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "d95d7d1e",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": []
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -286,10 +298,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "c1820623",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "class FQLAgent:\n",
     "    def __init__(self, hidden_units, learning_rate, learn_env, valid_env):\n",
@@ -401,6 +415,126 @@
     "                break"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "0fef8b68",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "class FQLAgent:\n",
+    "    def __init__(self, hidden_units, learning_rate, learn_env, valid_env):\n",
+    "        self.learn_env = learn_env\n",
+    "        self.valid_env = valid_env\n",
+    "        self.epsilon = 1.0\n",
+    "        self.epsilon_min = 0.1\n",
+    "        self.epsilon_decay = 0.98\n",
+    "        self.learning_rate = learning_rate\n",
+    "        self.gamma = 0.95\n",
+    "        self.batch_size = 128\n",
+    "        self.max_treward = 0\n",
+    "        self.trewards = list()\n",
+    "        self.averages = list()\n",
+    "        self.performances = list()\n",
+    "        self.aperformances = list()\n",
+    "        self.vperformances = list()\n",
+    "        self.memory = deque(maxlen=2000)\n",
+    "        self.model = self._build_model(hidden_units, learning_rate)\n",
+    "        \n",
+    "    def _build_model(self, hu, lr):\n",
+    "        model = Sequential()\n",
+    "        model.add(Dense(hu, input_shape=(\n",
+    "            self.learn_env.lags, self.learn_env.n_features),\n",
+    "                        activation='relu'))\n",
+    "        model.add(Dropout(0.3, seed=100))\n",
+    "        model.add(Dense(hu, activation='relu'))\n",
+    "        model.add(Dropout(0.3, seed=100))\n",
+    "        model.add(Dense(2, activation='linear'))\n",
+    "        model.compile(\n",
+    "            loss='mse',\n",
+    "            optimizer=keras.optimizers.RMSprop(learning_rate=lr)\n",
+    "        )\n",
+    "        return model\n",
+    "        \n",
+    "    def act(self, state):\n",
+    "        if random.random() <= self.epsilon:\n",
+    "            return self.learn_env.action_space.sample()\n",
+    "        action = self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()[0, 0]\n",
+    "        return np.argmax(action)\n",
+    "    \n",
+    "    def replay(self):\n",
+    "        batch = random.sample(self.memory, self.batch_size)\n",
+    "        for state, action, reward, next_state, done in batch:\n",
+    "            if not done:\n",
+    "                reward += self.gamma * np.amax(\n",
+    "                    self.model(tf.convert_to_tensor(next_state, dtype=tf.float32), training=False).numpy()[0, 0])\n",
+    "            target = self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()\n",
+    "            target[0, 0, action] = reward\n",
+    "            self.model.fit(state, target, epochs=1,\n",
+    "                           verbose=False)\n",
+    "        if self.epsilon > self.epsilon_min:\n",
+    "            self.epsilon *= self.epsilon_decay\n",
+    "    \n",
+    "    def learn(self, episodes):\n",
+    "        for e in range(1, episodes + 1):\n",
+    "            state = self.learn_env.reset()\n",
+    "            state = np.reshape(state, [1, self.learn_env.lags,\n",
+    "                                       self.learn_env.n_features])\n",
+    "            for _ in range(10000):\n",
+    "                action = self.act(state)\n",
+    "                next_state, reward, done, info = \\\n",
+    "                                self.learn_env.step(action)\n",
+    "                next_state = np.reshape(next_state,\n",
+    "                                [1, self.learn_env.lags,\n",
+    "                                 self.learn_env.n_features])\n",
+    "                self.memory.append([state, action, reward,\n",
+    "                                     next_state, done])\n",
+    "                state = next_state\n",
+    "                if done:\n",
+    "                    treward = _ + 1\n",
+    "                    self.trewards.append(treward)\n",
+    "                    av = sum(self.trewards[-25:]) / 25\n",
+    "                    perf = self.learn_env.performance\n",
+    "                    self.averages.append(av)\n",
+    "                    self.performances.append(perf)\n",
+    "                    self.aperformances.append(\n",
+    "                        sum(self.performances[-25:]) / 25)\n",
+    "                    self.max_treward = max(self.max_treward, treward)\n",
+    "                    templ = 'episode: {:2d}/{} | treward: {:4d} | '\n",
+    "                    templ += 'perf: {:5.3f} | av: {:5.1f} | max: {:4d}'\n",
+    "                    print(templ.format(e, episodes, treward, perf,\n",
+    "                                  av, self.max_treward), end='\\r')\n",
+    "                    break\n",
+    "            self.validate(e, episodes)\n",
+    "            if len(self.memory) > self.batch_size:\n",
+    "                self.replay()\n",
+    "    def validate(self, e, episodes):\n",
+    "        state = self.valid_env.reset()\n",
+    "        state = np.reshape(state, [1, self.valid_env.lags,\n",
+    "                                   self.valid_env.n_features])\n",
+    "        for _ in range(10000):\n",
+    "            action = np.argmax(self.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()[0, 0])\n",
+    "            next_state, reward, done, info = self.valid_env.step(action)\n",
+    "            state = np.reshape(next_state, [1, self.valid_env.lags,\n",
+    "                                   self.valid_env.n_features])\n",
+    "            if done:\n",
+    "                treward = _ + 1\n",
+    "                perf = self.valid_env.performance\n",
+    "                self.vperformances.append(perf)\n",
+    "                if e % 20 == 0:\n",
+    "                    templ = 71 * '='\n",
+    "                    templ += '\\nepisode: {:2d}/{} | VALIDATION | '\n",
+    "                    templ += 'treward: {:4d} | perf: {:5.3f} | '\n",
+    "                    templ += 'eps: {:.2f}\\n'\n",
+    "                    templ += 71 * '='\n",
+    "                    print(templ.format(e, episodes, treward,\n",
+    "                                       perf, self.epsilon))\n",
+    "                break"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -548,8 +682,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -566,4 +700,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/10_vectorized_backtesting.ipynb b/10_vectorized_backtesting.ipynb
index 5ba3971..c852c32 100755
--- a/10_vectorized_backtesting.ipynb
+++ b/10_vectorized_backtesting.ipynb
@@ -32,8 +32,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -546,13 +546,28 @@
     "model.evaluate(train_[cols], train['d'])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "a6061477",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "train['p'] = np.where(model.predict(train_[cols]) > 0.5, 1, 0)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "97c5daac",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "train['p'] = np.where(model.predict(train_[cols]) > 0.5, 1, 0)"
+    "import tensorflow as tf\n",
+    "train['p'] = np.where(model(tf.convert_to_tensor(train_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, 0)"
    ]
   },
   {
@@ -636,13 +651,28 @@
     "model.evaluate(test_[cols], test['d'])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "bf1bda70",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, -1)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "d2fee960",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, -1)"
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(test_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, -1)"
    ]
   },
   {
@@ -946,13 +976,28 @@
     "model.evaluate(train_[cols], train['d'])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "e9006f8b",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "train['p'] = np.where(model.predict(train_[cols]) > 0.5, 1, -1)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "34523657",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "train['p'] = np.where(model.predict(train_[cols]) > 0.5, 1, -1)"
+    "import tensorflow as tf\n",
+    "train['p'] = np.where(model(tf.convert_to_tensor(train_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, -1)"
    ]
   },
   {
@@ -1027,13 +1072,28 @@
     "model.evaluate(test_[cols], test['d'])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "02ad23e0",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, -1)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "e6b468ac",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "test['p'] = np.where(model.predict(test_[cols]) > 0.5, 1, -1)"
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(test_[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, -1)"
    ]
   },
   {
@@ -1190,8 +1250,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -1208,4 +1268,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/11_risk_management.ipynb b/11_risk_management.ipynb
index 3cc433a..99ddc53 100755
--- a/11_risk_management.ipynb
+++ b/11_risk_management.ipynb
@@ -32,8 +32,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -207,12 +207,39 @@
     "                          learn_env.n_features])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "3c3757b8",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "def backtest(agent, env):\n",
+    "    env.min_accuracy = 0.0\n",
+    "    env.min_performance = 0.0\n",
+    "    done = False\n",
+    "    env.data['p'] = 0\n",
+    "    state = env.reset()\n",
+    "    while not done:\n",
+    "        action = np.argmax(\n",
+    "            agent.model.predict(reshape(state))[0, 0])\n",
+    "        position = 1 if action == 1 else -1\n",
+    "        env.data.loc[:, 'p'].iloc[env.bar] = position\n",
+    "        state, reward, done, info = env.step(action)\n",
+    "    env.data['s'] = env.data['p'] * env.data['r'] * learn_env.leverage"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "0895f23a",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "def backtest(agent, env):\n",
     "    env.min_accuracy = 0.0\n",
     "    env.min_performance = 0.0\n",
@@ -221,7 +248,7 @@
     "    state = env.reset()\n",
     "    while not done:\n",
     "        action = np.argmax(\n",
-    "            agent.model.predict(reshape(state))[0, 0])\n",
+    "            agent.model(tf.convert_to_tensor(reshape(state, dtype=tf.float32), training=False).numpy())[0, 0])\n",
     "        position = 1 if action == 1 else -1\n",
     "        env.data.loc[:, 'p'].iloc[env.bar] = position\n",
     "        state, reward, done, info = env.step(action)\n",
@@ -452,12 +479,80 @@
     "bb.close_out(3 * bar)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "30dd060a",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "class TBBacktester(bt.BacktestingBase):\n",
+    "    def _reshape(self, state):\n",
+    "        ''' Helper method to reshape state objects.\n",
+    "        '''\n",
+    "        return np.reshape(state, [1, self.env.lags, self.env.n_features])\n",
+    "    def backtest_strategy(self):\n",
+    "        ''' Event-based backtesting of the trading bot's performance.\n",
+    "        '''\n",
+    "        self.units = 0\n",
+    "        self.position = 0\n",
+    "        self.trades = 0\n",
+    "        self.current_balance = self.initial_amount\n",
+    "        self.net_wealths = list()\n",
+    "        for bar in range(self.env.lags, len(self.env.data)):\n",
+    "            date, price = self.get_date_price(bar)\n",
+    "            if self.trades == 0:\n",
+    "                print(50 * '=')\n",
+    "                print(f'{date} | *** START BACKTEST ***')\n",
+    "                self.print_balance(bar)\n",
+    "                print(50 * '=')\n",
+    "            state = self.env.get_state(bar)\n",
+    "            action = np.argmax(self.model.predict(\n",
+    "                        self._reshape(state.values))[0, 0])\n",
+    "            position = 1 if action == 1 else -1\n",
+    "            if self.position in [0, -1] and position == 1:\n",
+    "                if self.verbose:\n",
+    "                    print(50 * '-')\n",
+    "                    print(f'{date} | *** GOING LONG ***')\n",
+    "                if self.position == -1:\n",
+    "                    self.place_buy_order(bar - 1, units=-self.units)\n",
+    "                self.place_buy_order(bar - 1,\n",
+    "                                     amount=self.current_balance)\n",
+    "                if self.verbose:\n",
+    "                    self.print_net_wealth(bar)\n",
+    "                self.position = 1\n",
+    "            elif self.position in [0, 1] and position == -1:\n",
+    "                if self.verbose:\n",
+    "                    print(50 * '-')\n",
+    "                    print(f'{date} | *** GOING SHORT ***')\n",
+    "                if self.position == 1:\n",
+    "                    self.place_sell_order(bar - 1, units=self.units)\n",
+    "                self.place_sell_order(bar - 1,\n",
+    "                                      amount=self.current_balance)\n",
+    "                if self.verbose:\n",
+    "                    self.print_net_wealth(bar)\n",
+    "                self.position = -1\n",
+    "            self.net_wealths.append((date,\n",
+    "                                     self.calculate_net_wealth(price)))\n",
+    "        self.net_wealths = pd.DataFrame(self.net_wealths,\n",
+    "                                        columns=['date', 'net_wealth'])\n",
+    "        self.net_wealths.set_index('date', inplace=True)\n",
+    "        self.net_wealths.index = pd.DatetimeIndex(\n",
+    "                                        self.net_wealths.index)\n",
+    "        self.close_out(bar)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "6c4b6cdf",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "class TBBacktester(bt.BacktestingBase):\n",
     "    def _reshape(self, state):\n",
     "        ''' Helper method to reshape state objects.\n",
@@ -479,8 +574,7 @@
     "                self.print_balance(bar)\n",
     "                print(50 * '=')\n",
     "            state = self.env.get_state(bar)\n",
-    "            action = np.argmax(self.model.predict(\n",
-    "                        self._reshape(state.values))[0, 0])\n",
+    "            action = np.argmax(self.model(tf.convert_to_tensor(self._reshape(state.values, dtype=tf.float32), training=False).numpy())[0, 0])\n",
     "            position = 1 if action == 1 else -1\n",
     "            if self.position in [0, -1] and position == 1:\n",
     "                if self.verbose:\n",
@@ -946,8 +1040,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -964,4 +1058,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/12_execution_deployment.ipynb b/12_execution_deployment.ipynb
index 8f2328b..bb5ca6d 100755
--- a/12_execution_deployment.ipynb
+++ b/12_execution_deployment.ipynb
@@ -32,8 +32,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -872,12 +872,103 @@
     "import tpqoa"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "49fe3044",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "class OandaTradingBot(tpqoa.tpqoa):\n",
+    "    def __init__(self, config_file, agent, granularity, units,\n",
+    "                 verbose=True):\n",
+    "        super(OandaTradingBot, self).__init__(config_file)\n",
+    "        self.agent = agent\n",
+    "        self.symbol = self.agent.learn_env.symbol\n",
+    "        self.env = agent.learn_env\n",
+    "        self.window = self.env.window\n",
+    "        if granularity is None:\n",
+    "            self.granularity = agent.learn_env.granularity\n",
+    "        else:\n",
+    "            self.granularity = granularity\n",
+    "        self.units = units\n",
+    "        self.trades = 0\n",
+    "        self.position = 0\n",
+    "        self.tick_data = pd.DataFrame()\n",
+    "        self.min_length = (self.agent.learn_env.window +\n",
+    "                           self.agent.learn_env.lags)\n",
+    "        self.pl = list()\n",
+    "        self.verbose = verbose\n",
+    "    def _prepare_data(self):\n",
+    "        self.data['r'] = np.log(self.data / self.data.shift(1))\n",
+    "        self.data.dropna(inplace=True)\n",
+    "        self.data['s'] = self.data[self.symbol].rolling(\n",
+    "                                            self.window).mean()\n",
+    "        self.data['m'] = self.data['r'].rolling(self.window).mean()\n",
+    "        self.data['v'] = self.data['r'].rolling(self.window).std()\n",
+    "        self.data.dropna(inplace=True)\n",
+    "        # self.data_ = (self.data - self.env.mu) / self.env.std  # \"correct\" approach\n",
+    "        self.data_ = (self.data - self.data.mean()) / self.data.std()  # for demonstration\n",
+    "    def _resample_data(self):\n",
+    "        self.data = self.tick_data.resample(self.granularity,\n",
+    "                        label='right').last().ffill().iloc[:-1]\n",
+    "        self.data = pd.DataFrame(self.data['mid'])\n",
+    "        self.data.columns = [self.symbol,]\n",
+    "        self.data.index = self.data.index.tz_localize(None)\n",
+    "    def _get_state(self):\n",
+    "        state = self.data_[self.env.features].iloc[-self.env.lags:]\n",
+    "        return np.reshape(state.values, [1, self.env.lags,\n",
+    "                                         self.env.n_features])\n",
+    "    def report_trade(self, time, side, order):\n",
+    "        self.trades += 1\n",
+    "        pl = float(order['pl'])\n",
+    "        self.pl.append(pl)\n",
+    "        cpl = sum(self.pl)\n",
+    "        print('\\n' + 75 * '=')\n",
+    "        print(f'{time} | *** GOING {side} ({self.trades}) ***')\n",
+    "        print(f'{time} | PROFIT/LOSS={pl:.2f} | CUMULATIVE={cpl:.2f}')\n",
+    "        print(75 * '=')\n",
+    "        if self.verbose:\n",
+    "            pprint(order)\n",
+    "            print(75 * '=')\n",
+    "    def on_success(self, time, bid, ask):\n",
+    "        df = pd.DataFrame({'ask': ask, 'bid': bid,\n",
+    "                           'mid': (bid + ask) / 2},\n",
+    "                          index=[pd.Timestamp(time)])\n",
+    "        self.tick_data = self.tick_data.append(df)\n",
+    "        self._resample_data()\n",
+    "        if len(self.data) > self.min_length:\n",
+    "            self.min_length += 1\n",
+    "            self._prepare_data()\n",
+    "            state = self._get_state()\n",
+    "            prediction = np.argmax(\n",
+    "                self.agent.model.predict(state)[0, 0])\n",
+    "            position = 1 if prediction == 1 else -1\n",
+    "            if self.position in [0, -1] and position == 1:\n",
+    "                order = self.create_order(self.symbol,\n",
+    "                        units=(1 - self.position) * self.units,\n",
+    "                                suppress=True, ret=True)\n",
+    "                self.report_trade(time, 'LONG', order)\n",
+    "                self.position = 1\n",
+    "            elif self.position in [0, 1] and position == -1:\n",
+    "                order = self.create_order(self.symbol,\n",
+    "                        units=-(1 + self.position) * self.units,\n",
+    "                                suppress=True, ret=True)\n",
+    "                self.report_trade(time, 'SHORT', order)\n",
+    "                self.position = -1"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "33221ed9",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "class OandaTradingBot(tpqoa.tpqoa):\n",
     "    def __init__(self, config_file, agent, granularity, units,\n",
     "                 verbose=True):\n",
@@ -941,7 +1032,7 @@
     "            self._prepare_data()\n",
     "            state = self._get_state()\n",
     "            prediction = np.argmax(\n",
-    "                self.agent.model.predict(state)[0, 0])\n",
+    "                self.agent.model(tf.convert_to_tensor(state, dtype=tf.float32), training=False).numpy()[0, 0])\n",
     "            position = 1 if prediction == 1 else -1\n",
     "            if self.position in [0, -1] and position == 1:\n",
     "                order = self.create_order(self.symbol,\n",
@@ -1041,8 +1132,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -1059,4 +1150,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/B_neural_network_classes.ipynb b/B_neural_network_classes.ipynb
index 28d70e0..100ca0f 100755
--- a/B_neural_network_classes.ipynb
+++ b/B_neural_network_classes.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -267,10 +267,12 @@
    ]
   },
   {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {},
-   "outputs": [],
+   "cell_type": "raw",
+   "id": "4e53b73a",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "%time model.fit(l0, y, seed=100)"
    ]
@@ -278,8 +280,22 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "118db1c9",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "%time model.fit(l0, y, seed=100, verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "4132f63a",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "model.predict(l0)"
    ]
@@ -287,12 +303,40 @@
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "dfbfa5ad",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "model(tf.convert_to_tensor(l0, dtype=tf.float32), training=False).numpy()"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "d8e740c1",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
    "source": [
     "model.predict(l0) - y"
    ]
   },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "aabff41b",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
+   "outputs": [],
+   "source": [
+    "import tensorflow as tf\n",
+    "model(tf.convert_to_tensor(l0, dtype=tf.float32), training=False).numpy() - y"
+   ]
+  },
   {
    "cell_type": "markdown",
    "metadata": {},
@@ -349,13 +393,27 @@
     "model = sinn(lr=0.01, act='sigmoid')"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "b3fc26ca",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%time model.fit(l0, y, 4000)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "43bf6380",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "%time model.fit(l0, y, 4000)"
+    "%time model.fit(l0, y, 4000, verbose=0)"
    ]
   },
   {
@@ -367,13 +425,28 @@
     "model.l2"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "7554b3f1",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "model.predict(l0).round() == y"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "7dda000b",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "model.predict(l0).round() == y"
+    "import tensorflow as tf\n",
+    "model(tf.convert_to_tensor(l0, dtype=tf.float32), training=False).numpy().round() == y"
    ]
   },
   {
@@ -553,13 +626,27 @@
     "             verbose=True, psteps=2000, seed=100)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "5b5cf53c",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%time model.fit(l0, y, 8000)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "acf5d18b",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "%time model.fit(l0, y, 8000)"
+    "%time model.fit(l0, y, 8000, verbose=0)"
    ]
   },
   {
@@ -615,13 +702,27 @@
     "y.round()"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "9ac2a3df",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "model.fit(l0.round(), y.round())"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "ff3bfe94",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "model.fit(l0.round(), y.round())"
+    "model.fit(l0.round(, verbose=0), y.round())"
    ]
   },
   {
@@ -723,22 +824,51 @@
     "y = data['d'].values.reshape(-1, 1)"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "53bc15ce",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%time model.fit(data[cols].values, y)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "42b13d58",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "%time model.fit(data[cols].values, y)"
+    "%time model.fit(data[cols].values, y, verbose=0)"
+   ]
+  },
+  {
+   "cell_type": "raw",
+   "id": "3b31df92",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "data['p'] = np.where(model.predict(data[cols]) > 0.5, 1, -1)"
    ]
   },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "e9b35fbe",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "data['p'] = np.where(model.predict(data[cols]) > 0.5, 1, -1)"
+    "import tensorflow as tf\n",
+    "data['p'] = np.where(model(tf.convert_to_tensor(data[cols], dtype=tf.float32), training=False).numpy() > 0.5, 1, -1)"
    ]
   },
   {
@@ -789,8 +919,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -807,4 +937,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}
diff --git a/C_convolutional_neural_networks.ipynb b/C_convolutional_neural_networks.ipynb
index f706aa7..b59c027 100755
--- a/C_convolutional_neural_networks.ipynb
+++ b/C_convolutional_neural_networks.ipynb
@@ -39,8 +39,8 @@
   },
   {
    "cell_type": "code",
-   "metadata": {},
    "execution_count": null,
+   "metadata": {},
    "outputs": [],
    "source": [
     "!git clone https://github.com/tpq-classes/ai_in_finance_book.git\n",
@@ -264,14 +264,31 @@
     "model.summary()"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "426ac8a8",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "%%time\n",
+    "model.fit(np.atleast_3d(train[cols]), train['d'],\n",
+    "          epochs=60, batch_size=48, verbose=False,\n",
+    "          validation_split=0.15, shuffle=False)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "db7673d2",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
     "%%time\n",
-    "model.fit(np.atleast_3d(train[cols]), train['d'],\n",
+    "model.fit(np.atleast_3d(train[cols], verbose=0), train['d'],\n",
     "          epochs=60, batch_size=48, verbose=False,\n",
     "          validation_split=0.15, shuffle=False)"
    ]
@@ -312,13 +329,28 @@
     "model.evaluate(np.atleast_3d(test[cols]), test['d'])"
    ]
   },
+  {
+   "cell_type": "raw",
+   "id": "c9cb45b6",
+   "metadata": {
+    "auto_refactor_original_cell_type": "code",
+    "auto_refactor_role": "raw_backup"
+   },
+   "source": [
+    "test['p'] = np.where(model.predict(np.atleast_3d(test[cols])) > 0.5, 1, 0)"
+   ]
+  },
   {
    "cell_type": "code",
    "execution_count": null,
-   "metadata": {},
+   "id": "b01426b7",
+   "metadata": {
+    "auto_refactor_role": "generated"
+   },
    "outputs": [],
    "source": [
-    "test['p'] = np.where(model.predict(np.atleast_3d(test[cols])) > 0.5, 1, 0)"
+    "import tensorflow as tf\n",
+    "test['p'] = np.where(model(tf.convert_to_tensor(np.atleast_3d(test[cols], dtype=tf.float32), training=False).numpy()) > 0.5, 1, 0)"
    ]
   },
   {
@@ -403,8 +435,8 @@
  ],
  "metadata": {
   "kernelspec": {
-   "name": "python3",
-   "display_name": "Python 3"
+   "display_name": "Python 3",
+   "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
@@ -421,4 +453,4 @@
  },
  "nbformat": 4,
  "nbformat_minor": 4
-}
\ No newline at end of file
+}